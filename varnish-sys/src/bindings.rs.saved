/* automatically generated by rust-bindgen 0.59.2 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _MATH_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 33;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const __jmp_buf_tag_defined: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const VRT_INTEGER_MAX: u64 = 999999999999999;
pub const VRT_INTEGER_MIN: i64 = -999999999999999;
pub const VRT_MAJOR_VERSION: u32 = 14;
pub const VRT_MINOR_VERSION: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const VRT_NULL_BLOB_TYPE: u32 = 4208873376;
pub const VRT_CTX_MAGIC: u32 = 1807282395;
pub const VRT_ENDPOINT_MAGIC: u32 = 3426849607;
pub const VRT_BACKEND_MAGIC: u32 = 1201262188;
pub const VRT_BACKEND_PROBE_MAGIC: u32 = 2224653456;
pub const VDI_METHODS_MAGIC: u32 = 1321256123;
pub const DIRECTOR_MAGIC: u32 = 859190557;
pub const VMOD_PRIV_METHODS_MAGIC: u32 = 3466985369;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const VSPLAY_NEGINF: i32 = -1;
pub const VSPLAY_INF: u32 = 1;
pub const VRBT_NEGINF: i32 = -1;
pub const VRBT_INF: u32 = 1;
pub const VSL_CLASS: &[u8; 4usize] = b"Log\0";
pub const VSL_SEGMENTS: u32 = 8;
pub const VSL_CLIENTMARKER: u32 = 1073741824;
pub const VSL_BACKENDMARKER: u32 = 2147483648;
pub const VSL_IDENTMASK: i64 = -3221225473;
pub const VSL_LENMASK: u32 = 65535;
pub const SLT__MAX: u32 = 256;
pub const NODEF_NOTICE: &[u8; 44usize] = b"NB: This log record is masked by default.\n\n\0";
pub const NOSUP_NOTICE : & [u8 ; 171usize] = b"NOTE: This tag is currently not in use in the Varnish log.\nIt is mentioned here to document legacy versions of the log,\nor reserved for possible use in future versions.\n\n\0" ;
pub const HEADER_NOTICE : & [u8 ; 189usize] = b"NOTE: HTTP header fields are free form records and not strictly\nmade of 2 fields. Accessing a specific header with the prefix\nnotation helps treating the header value as a single string.\n\n\0" ;
pub const SLT_F_UNUSED: u32 = 1;
pub const SLT_F_UNSAFE: u32 = 2;
pub const SLT_F_BINARY: u32 = 4;
pub const DIGEST_LEN: u32 = 32;
pub const WS_ID_SIZE: u32 = 4;
pub const WS_MAGIC: u32 = 905626964;
pub const HTTP_MAGIC: u32 = 1680389577;
pub const HDF_FILTER: u32 = 1;
pub const WORKER_MAGIC: u32 = 1670491599;
pub const BOC_MAGIC: u32 = 1892254838;
pub const OBJCORE_MAGIC: u32 = 1294996226;
pub const BUSYOBJ_MAGIC: u32 = 599348583;
pub const REQTOP_MAGIC: u32 = 1476123218;
pub const REQ_MAGIC: u32 = 4215979885;
pub const RES_ESI: u32 = 16;
pub const RES_PIPE: u32 = 128;
pub const SESS_MAGIC: u32 = 741317722;
pub const HTTPH_R_PASS: u32 = 1;
pub const HTTPH_R_FETCH: u32 = 2;
pub const HTTPH_A_INS: u32 = 4;
pub const HTTPH_A_PASS: u32 = 8;
pub const HTTPH_C_SPECIFIC: u32 = 16;
pub const P: u32 = 1;
pub const F: u32 = 2;
pub const I: u32 = 4;
pub const S: u32 = 8;
pub const K: u32 = 16;
pub const OBJ_ITER_FLUSH: u32 = 1;
pub const OBJ_ITER_END: u32 = 2;
pub const VFP_ENTRY_MAGIC: u32 = 3190988839;
pub const VFP_CTX_MAGIC: u32 = 1641665509;
pub const VDP_ENTRY_MAGIC: u32 = 893302657;
pub const VDP_CTX_MAGIC: u32 = 3998227959;
pub const VMOD_ABI_Version: &[u8; 55usize] =
    b"Varnish 7.0.2 9b5f68e19ca0ab60010641e305fd12822f18d42c\0";
pub const VSB_MAGIC: u32 = 1250090378;
pub const VSB_FIXEDLEN: u32 = 0;
pub const VSB_AUTOEXTEND: u32 = 1;
pub const VSB_USRFLAGMSK: u32 = 65535;
pub const VSB_DYNAMIC: u32 = 65536;
pub const VSB_FINISHED: u32 = 131072;
pub const VSB_DYNSTRUCT: u32 = 524288;
pub const VSB_QUOTE_PLAIN: u32 = 0;
pub const VSB_QUOTE_JSON: u32 = 2;
pub const VSB_QUOTE_HEX: u32 = 4;
pub const VSB_QUOTE_CSTR: u32 = 8;
pub const VSB_QUOTE_UNSAFE: u32 = 16;
pub const VSB_QUOTE_NONL: u32 = 1;
pub const VSB_QUOTE_ESCHEX: u32 = 32;
pub const HTTP_CONN_MAGIC: u32 = 1041886673;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigl(__x: u128, __y: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn expl(__x: u128) -> u128;
}
extern "C" {
    pub fn __expl(__x: u128) -> u128;
}
extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn logl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logl(__x: u128) -> u128;
}
extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn __expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn __log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn __ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn __fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn __floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn __significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn __scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn __roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn __truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
pub const FP_NAN: ::std::os::raw::c_uint = 0;
pub const FP_INFINITE: ::std::os::raw::c_uint = 1;
pub const FP_ZERO: ::std::os::raw::c_uint = 2;
pub const FP_SUBNORMAL: ::std::os::raw::c_uint = 3;
pub const FP_NORMAL: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub type size_t = ::std::os::raw::c_ulong;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_set_t>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: size_t, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: size_t) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
pub type clock_t = __clock_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
impl Default for tm {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
impl Default for __locale_struct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_list {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_slist {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
impl Default for __pthread_mutex_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
impl Default for __pthread_cond_s__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
impl Default for __pthread_cond_s__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
impl Default for __pthread_cond_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__once_flag>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutexattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_condattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_attr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutex_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_cond_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_rwlock_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_rwlockattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_barrier_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_barrierattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
#[test]
fn bindgen_test_layout___jmp_buf_tag() {
    assert_eq!(
        ::std::mem::size_of::<__jmp_buf_tag>(),
        200usize,
        concat!("Size of: ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__jmp_buf_tag>())).__jmpbuf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__jmpbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__jmp_buf_tag>())).__mask_was_saved as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__jmp_buf_tag>())).__saved_mask as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__saved_mask)
        )
    );
}
pub const PTHREAD_CREATE_JOINABLE: ::std::os::raw::c_uint = 0;
pub const PTHREAD_CREATE_DETACHED: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: ::std::os::raw::c_uint = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: ::std::os::raw::c_uint = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: ::std::os::raw::c_uint = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: ::std::os::raw::c_uint = 3;
pub const PTHREAD_MUTEX_NORMAL: ::std::os::raw::c_uint = 0;
pub const PTHREAD_MUTEX_RECURSIVE: ::std::os::raw::c_uint = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: ::std::os::raw::c_uint = 2;
pub const PTHREAD_MUTEX_DEFAULT: ::std::os::raw::c_uint = 0;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_STALLED: ::std::os::raw::c_uint = 0;
pub const PTHREAD_MUTEX_STALLED_NP: ::std::os::raw::c_uint = 0;
pub const PTHREAD_MUTEX_ROBUST: ::std::os::raw::c_uint = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const PTHREAD_PRIO_NONE: ::std::os::raw::c_uint = 0;
pub const PTHREAD_PRIO_INHERIT: ::std::os::raw::c_uint = 1;
pub const PTHREAD_PRIO_PROTECT: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: ::std::os::raw::c_uint = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: ::std::os::raw::c_uint = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: ::std::os::raw::c_uint = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: ::std::os::raw::c_uint = 0;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const PTHREAD_INHERIT_SCHED: ::std::os::raw::c_uint = 0;
pub const PTHREAD_EXPLICIT_SCHED: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: ::std::os::raw::c_uint = 0;
pub const PTHREAD_SCOPE_PROCESS: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: ::std::os::raw::c_uint = 0;
pub const PTHREAD_PROCESS_SHARED: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__canceltype as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
impl Default for _pthread_cleanup_buffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const PTHREAD_CANCEL_ENABLE: ::std::os::raw::c_uint = 0;
pub const PTHREAD_CANCEL_DISABLE: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: ::std::os::raw::c_uint = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __cancel_jmp_buf_tag {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___cancel_jmp_buf_tag() {
    assert_eq!(
        ::std::mem::size_of::<__cancel_jmp_buf_tag>(),
        72usize,
        concat!("Size of: ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__cancel_jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__cancel_jmp_buf_tag>())).__cancel_jmp_buf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__cancel_jmp_buf_tag>())).__mask_was_saved as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__cancel_jmp_buf_tag; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__cancel_jmp_buf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__pad as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
impl Default for __pthread_unwind_buf_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_routine as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__do_it as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_type as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
impl Default for __pthread_cleanup_frame {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type vtim_mono = f64;
pub type vtim_real = f64;
pub type vtim_dur = f64;
#[doc = " txt (vas.h needed for the macros)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct txt {
    pub b: *const ::std::os::raw::c_char,
    pub e: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_txt() {
    assert_eq!(
        ::std::mem::size_of::<txt>(),
        16usize,
        concat!("Size of: ", stringify!(txt))
    );
    assert_eq!(
        ::std::mem::align_of::<txt>(),
        8usize,
        concat!("Alignment of ", stringify!(txt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<txt>())).b as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(txt), "::", stringify!(b))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<txt>())).e as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(txt), "::", stringify!(e))
    );
}
impl Default for txt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stevedore {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct suckaddr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vcl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vcldir {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCL_conf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vcl_sub {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmod {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_acl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VSC_main {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsc_seg {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsmw_cluster {
    _unused: [u8; 0],
}
#[doc = " VCL_STRANDS:"]
#[doc = ""]
#[doc = " An argc+argv type of data structure where n indicates the number of"]
#[doc = " strings in the p array. Individual components of a strands may be null."]
#[doc = ""]
#[doc = " A STRANDS allows you to work on a strings concatenation with the"]
#[doc = " option to collect it into a single STRING, or if possible work"]
#[doc = " directly on individual parts."]
#[doc = ""]
#[doc = " The memory management is very strict: a VMOD function receiving a"]
#[doc = " STRANDS argument should keep no reference after the function returns."]
#[doc = " Retention of a STRANDS further in the ongoing task is undefined"]
#[doc = " behavior and may result in a panic or data corruption."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct strands {
    pub n: ::std::os::raw::c_int,
    pub p: *mut *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_strands() {
    assert_eq!(
        ::std::mem::size_of::<strands>(),
        16usize,
        concat!("Size of: ", stringify!(strands))
    );
    assert_eq!(
        ::std::mem::align_of::<strands>(),
        8usize,
        concat!("Alignment of ", stringify!(strands))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strands>())).n as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(strands),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strands>())).p as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(strands),
            "::",
            stringify!(p)
        )
    );
}
impl Default for strands {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut vrt_null_strands: *const strands;
}
#[doc = " VCL_BLOB:"]
#[doc = ""]
#[doc = " Opaque, immutable data (pointer + length), minimum lifetime is the"]
#[doc = " VCL task."]
#[doc = ""]
#[doc = " Type (optional) is owned by the creator of the blob. blob consumers"]
#[doc = " may use it for checks, but should not assert on it."]
#[doc = ""]
#[doc = " The data behind the blob pointer is assumed to be immutable for the"]
#[doc = " blob's lifetime."]
#[doc = ""]
#[doc = " - memory for shortlived blobs can be put on the tasks workspace"]
#[doc = ""]
#[doc = " - management of memory for longer lived blobs is up to the vmod"]
#[doc = "   (in which case the blob will probably be embedded in an object or"]
#[doc = "    referenced by other state with vcl lifetime)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_blob {
    pub type_: ::std::os::raw::c_uint,
    pub len: size_t,
    pub blob: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_vrt_blob() {
    assert_eq!(
        ::std::mem::size_of::<vrt_blob>(),
        24usize,
        concat!("Size of: ", stringify!(vrt_blob))
    );
    assert_eq!(
        ::std::mem::align_of::<vrt_blob>(),
        8usize,
        concat!("Alignment of ", stringify!(vrt_blob))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_blob>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_blob),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_blob>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_blob),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_blob>())).blob as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_blob),
            "::",
            stringify!(blob)
        )
    );
}
impl Default for vrt_blob {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut vrt_null_blob: *const vrt_blob;
}
#[doc = " This is the central definition of the mapping from VCL types to"]
#[doc = " C-types.  The python scripts read these from here."]
#[doc = " (keep alphabetic order)"]
pub type VCL_ACL = *const vrt_acl;
pub type VCL_BACKEND = *const director;
pub type VCL_BLOB = *const vrt_blob;
pub type VCL_BODY = *const ::std::os::raw::c_char;
pub type VCL_BOOL = ::std::os::raw::c_uint;
pub type VCL_BYTES = i64;
pub type VCL_DURATION = vtim_dur;
pub type VCL_ENUM = *const ::std::os::raw::c_char;
pub type VCL_HEADER = *const gethdr_s;
pub type VCL_HTTP = *mut http;
pub type VCL_INSTANCE = ::std::os::raw::c_void;
pub type VCL_INT = i64;
pub type VCL_IP = *const suckaddr;
pub type VCL_PROBE = *const vrt_backend_probe;
pub type VCL_REAL = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vre {
    _unused: [u8; 0],
}
pub type VCL_REGEX = *const vre;
pub type VCL_STEVEDORE = *const stevedore;
pub type VCL_STRANDS = *const strands;
pub type VCL_STRING = *const ::std::os::raw::c_char;
pub type VCL_SUB = *const vcl_sub;
pub type VCL_TIME = vtim_real;
pub type VCL_VCL = *mut vcl;
pub type VCL_VOID = ::std::os::raw::c_void;
#[doc = " This is the composite \"context\" argument for compiled VCL, VRT and"]
#[doc = " VMOD functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_ctx {
    pub magic: ::std::os::raw::c_uint,
    pub syntax: ::std::os::raw::c_uint,
    pub vclver: ::std::os::raw::c_uint,
    pub method: ::std::os::raw::c_uint,
    pub handling: *mut ::std::os::raw::c_uint,
    pub msg: *mut vsb,
    pub vsl: *mut vsl_log,
    pub vcl: VCL_VCL,
    pub ws: *mut ws,
    pub sp: *mut sess,
    pub req: *mut req,
    pub http_req: VCL_HTTP,
    pub http_req_top: VCL_HTTP,
    pub http_resp: VCL_HTTP,
    pub bo: *mut busyobj,
    pub http_bereq: VCL_HTTP,
    pub http_beresp: VCL_HTTP,
    pub now: vtim_real,
    pub specific: *mut ::std::os::raw::c_void,
    pub called: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_vrt_ctx() {
    assert_eq!(
        ::std::mem::size_of::<vrt_ctx>(),
        144usize,
        concat!("Size of: ", stringify!(vrt_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<vrt_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(vrt_ctx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_ctx>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_ctx>())).syntax as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(syntax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_ctx>())).vclver as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(vclver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_ctx>())).method as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_ctx>())).handling as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(handling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_ctx>())).msg as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(msg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_ctx>())).vsl as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(vsl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_ctx>())).vcl as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(vcl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_ctx>())).ws as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(ws)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_ctx>())).sp as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_ctx>())).req as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_ctx>())).http_req as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(http_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_ctx>())).http_req_top as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(http_req_top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_ctx>())).http_resp as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(http_resp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_ctx>())).bo as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(bo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_ctx>())).http_bereq as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(http_bereq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_ctx>())).http_beresp as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(http_beresp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_ctx>())).now as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(now)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_ctx>())).specific as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(specific)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_ctx>())).called as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_ctx),
            "::",
            stringify!(called)
        )
    );
}
impl Default for vrt_ctx {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VRT_CTX_Assert(ctx: *const vrt_ctx);
}
pub const vcl_func_call_e_VSUB_STATIC: vcl_func_call_e = 0;
pub const vcl_func_call_e_VSUB_DYNAMIC: vcl_func_call_e = 1;
pub const vcl_func_call_e_VSUB_CHECK: vcl_func_call_e = 2;
pub type vcl_func_call_e = ::std::os::raw::c_uint;
pub const vcl_func_fail_e_VSUB_E_OK: vcl_func_fail_e = 0;
pub const vcl_func_fail_e_VSUB_E_RECURSE: vcl_func_fail_e = 1;
pub const vcl_func_fail_e_VSUB_E_METHOD: vcl_func_fail_e = 2;
pub type vcl_func_fail_e = ::std::os::raw::c_uint;
pub type vcl_func_f = ::std::option::Option<
    unsafe extern "C" fn(ctx: *const vrt_ctx, arg1: vcl_func_call_e, arg2: *mut vcl_func_fail_e),
>;
#[doc = " This is the interface structure to a compiled VMOD"]
#[doc = " (produced by vmodtool.py)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmod_data {
    pub vrt_major: ::std::os::raw::c_uint,
    pub vrt_minor: ::std::os::raw::c_uint,
    pub file_id: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
    pub func_name: *const ::std::os::raw::c_char,
    pub func: *const ::std::os::raw::c_void,
    pub func_len: ::std::os::raw::c_int,
    pub proto: *const ::std::os::raw::c_char,
    pub json: *const ::std::os::raw::c_char,
    pub abi: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_vmod_data() {
    assert_eq!(
        ::std::mem::size_of::<vmod_data>(),
        72usize,
        concat!("Size of: ", stringify!(vmod_data))
    );
    assert_eq!(
        ::std::mem::align_of::<vmod_data>(),
        8usize,
        concat!("Alignment of ", stringify!(vmod_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmod_data>())).vrt_major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(vrt_major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmod_data>())).vrt_minor as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(vrt_minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmod_data>())).file_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(file_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmod_data>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmod_data>())).func_name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(func_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmod_data>())).func as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmod_data>())).func_len as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(func_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmod_data>())).proto as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmod_data>())).json as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(json)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmod_data>())).abi as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_data),
            "::",
            stringify!(abi)
        )
    );
}
impl Default for vmod_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const vcl_event_e_VCL_EVENT_LOAD: vcl_event_e = 0;
pub const vcl_event_e_VCL_EVENT_WARM: vcl_event_e = 1;
pub const vcl_event_e_VCL_EVENT_COLD: vcl_event_e = 2;
pub const vcl_event_e_VCL_EVENT_DISCARD: vcl_event_e = 3;
#[doc = " VCL events sent to VMODs"]
pub type vcl_event_e = ::std::os::raw::c_uint;
pub type vmod_event_f = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *const vrt_ctx,
        arg1: *mut vmod_priv,
        arg2: vcl_event_e,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Utility functions operating on VCL_types"]
    #[doc = " (alphabetic by type-ish)"]
    pub fn VRT_acl_match(ctx: *const vrt_ctx, arg1: VCL_ACL, arg2: VCL_IP)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VRT_DirectorResolve(ctx: *const vrt_ctx, arg1: VCL_BACKEND) -> VCL_BACKEND;
}
extern "C" {
    pub fn VRT_blob(
        ctx: *const vrt_ctx,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_void,
        arg3: size_t,
        arg4: ::std::os::raw::c_uint,
    ) -> VCL_BLOB;
}
extern "C" {
    pub fn VRT_INT_is_valid(arg1: VCL_INT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VRT_VSA_GetPtr(
        ctx: *const vrt_ctx,
        sua: VCL_IP,
        dst: *mut *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VRT_ipcmp(ctx: *const vrt_ctx, arg1: VCL_IP, arg2: VCL_IP) -> VCL_BOOL;
}
extern "C" {
    pub fn VRT_Format_Proxy(
        arg1: *mut vsb,
        arg2: VCL_INT,
        arg3: VCL_IP,
        arg4: VCL_IP,
        arg5: VCL_STRING,
    );
}
extern "C" {
    pub fn VRT_REAL_is_valid(arg1: VCL_REAL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VRT_re_match(ctx: *const vrt_ctx, arg1: VCL_STRING, arg2: VCL_REGEX) -> VCL_BOOL;
}
extern "C" {
    pub fn VRT_regsub(
        ctx: *const vrt_ctx,
        all: ::std::os::raw::c_int,
        arg1: VCL_STRING,
        arg2: VCL_REGEX,
        arg3: VCL_STRING,
    ) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_stevedore(nm: *const ::std::os::raw::c_char) -> VCL_STEVEDORE;
}
extern "C" {
    pub fn VRT_AllocStrandsWS(arg1: *mut ws, arg2: ::std::os::raw::c_int) -> *mut strands;
}
extern "C" {
    pub fn VRT_CompareStrands(a: VCL_STRANDS, b: VCL_STRANDS) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VRT_Strands2Bool(arg1: VCL_STRANDS) -> VCL_BOOL;
}
extern "C" {
    pub fn VRT_HashStrands32(arg1: VCL_STRANDS) -> u32;
}
extern "C" {
    pub fn VRT_Strands(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: VCL_STRANDS,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn VRT_StrandsWS(
        arg1: *mut ws,
        arg2: *const ::std::os::raw::c_char,
        arg3: VCL_STRANDS,
    ) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_UpperLowerStrands(
        ctx: *const vrt_ctx,
        s: VCL_STRANDS,
        up: ::std::os::raw::c_int,
    ) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_check_call(ctx: *const vrt_ctx, arg1: VCL_SUB) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_call(ctx: *const vrt_ctx, arg1: VCL_SUB) -> VCL_VOID;
}
extern "C" {
    pub fn VRT_BACKEND_string(arg1: VCL_BACKEND) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_BOOL_string(arg1: VCL_BOOL) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_BLOB_string(ctx: *const vrt_ctx, arg1: VCL_BLOB) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_CollectString(
        ctx: *const vrt_ctx,
        p: *const ::std::os::raw::c_char,
        ...
    ) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_INT_string(ctx: *const vrt_ctx, arg1: VCL_INT) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_IP_string(ctx: *const vrt_ctx, arg1: VCL_IP) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_REAL_string(ctx: *const vrt_ctx, arg1: VCL_REAL) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_STEVEDORE_string(arg1: VCL_STEVEDORE) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_STRANDS_string(ctx: *const vrt_ctx, arg1: VCL_STRANDS) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_TIME_string(ctx: *const vrt_ctx, arg1: VCL_TIME) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_strcmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VRT_memmove(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_uint,
    );
}
#[doc = " We want the VCC to spit this structs out as const, but when VMODs"]
#[doc = " come up with them we want to clone them into malloc'ed space which"]
#[doc = " we can free again."]
#[doc = " We collect all the knowledge here by macroizing the fields and make"]
#[doc = " a macro for handling them all."]
#[doc = " See also:  cache_backend.h & cache_backend_cfg.c"]
#[doc = " One of those things..."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_endpoint {
    pub magic: ::std::os::raw::c_uint,
    pub ipv4: VCL_IP,
    pub ipv6: VCL_IP,
    pub uds_path: *const ::std::os::raw::c_char,
    pub preamble: *const vrt_blob,
}
#[test]
fn bindgen_test_layout_vrt_endpoint() {
    assert_eq!(
        ::std::mem::size_of::<vrt_endpoint>(),
        40usize,
        concat!("Size of: ", stringify!(vrt_endpoint))
    );
    assert_eq!(
        ::std::mem::align_of::<vrt_endpoint>(),
        8usize,
        concat!("Alignment of ", stringify!(vrt_endpoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_endpoint>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_endpoint),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_endpoint>())).ipv4 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_endpoint),
            "::",
            stringify!(ipv4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_endpoint>())).ipv6 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_endpoint),
            "::",
            stringify!(ipv6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_endpoint>())).uds_path as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_endpoint),
            "::",
            stringify!(uds_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_endpoint>())).preamble as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_endpoint),
            "::",
            stringify!(preamble)
        )
    );
}
impl Default for vrt_endpoint {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_backend {
    pub magic: ::std::os::raw::c_uint,
    pub endpoint: *const vrt_endpoint,
    pub vcl_name: *const ::std::os::raw::c_char,
    pub hosthdr: *const ::std::os::raw::c_char,
    pub connect_timeout: vtim_dur,
    pub first_byte_timeout: vtim_dur,
    pub between_bytes_timeout: vtim_dur,
    pub max_connections: ::std::os::raw::c_uint,
    pub proxy_header: ::std::os::raw::c_uint,
    pub probe: VCL_PROBE,
}
#[test]
fn bindgen_test_layout_vrt_backend() {
    assert_eq!(
        ::std::mem::size_of::<vrt_backend>(),
        72usize,
        concat!("Size of: ", stringify!(vrt_backend))
    );
    assert_eq!(
        ::std::mem::align_of::<vrt_backend>(),
        8usize,
        concat!("Alignment of ", stringify!(vrt_backend))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_backend>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_backend>())).endpoint as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_backend>())).vcl_name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(vcl_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_backend>())).hosthdr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(hosthdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_backend>())).connect_timeout as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(connect_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_backend>())).first_byte_timeout as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(first_byte_timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vrt_backend>())).between_bytes_timeout as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(between_bytes_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_backend>())).max_connections as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(max_connections)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_backend>())).proxy_header as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(proxy_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_backend>())).probe as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend),
            "::",
            stringify!(probe)
        )
    );
}
impl Default for vrt_backend {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_backend_probe {
    pub magic: ::std::os::raw::c_uint,
    pub url: *const ::std::os::raw::c_char,
    pub request: *const ::std::os::raw::c_char,
    pub timeout: vtim_dur,
    pub interval: vtim_dur,
    pub exp_status: ::std::os::raw::c_uint,
    pub window: ::std::os::raw::c_uint,
    pub threshold: ::std::os::raw::c_uint,
    pub initial: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_vrt_backend_probe() {
    assert_eq!(
        ::std::mem::size_of::<vrt_backend_probe>(),
        56usize,
        concat!("Size of: ", stringify!(vrt_backend_probe))
    );
    assert_eq!(
        ::std::mem::align_of::<vrt_backend_probe>(),
        8usize,
        concat!("Alignment of ", stringify!(vrt_backend_probe))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_backend_probe>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_backend_probe>())).url as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(url)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_backend_probe>())).request as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_backend_probe>())).timeout as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_backend_probe>())).interval as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_backend_probe>())).exp_status as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(exp_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_backend_probe>())).window as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_backend_probe>())).threshold as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_backend_probe>())).initial as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_backend_probe),
            "::",
            stringify!(initial)
        )
    );
}
impl Default for vrt_backend_probe {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VRT_new_backend(ctx: *const vrt_ctx, arg1: *const vrt_backend) -> VCL_BACKEND;
}
extern "C" {
    pub fn VRT_new_backend_clustered(
        ctx: *const vrt_ctx,
        arg1: *mut vsmw_cluster,
        arg2: *const vrt_backend,
    ) -> VCL_BACKEND;
}
extern "C" {
    pub fn VRT_backend_vsm_need(ctx: *const vrt_ctx) -> size_t;
}
extern "C" {
    pub fn VRT_delete_backend(ctx: *const vrt_ctx, arg1: *mut VCL_BACKEND);
}
extern "C" {
    pub fn VRT_Endpoint_Clone(vep: *const vrt_endpoint) -> *mut vrt_endpoint;
}
pub const gethdr_e_HDR_REQ: gethdr_e = 0;
pub const gethdr_e_HDR_REQ_TOP: gethdr_e = 1;
pub const gethdr_e_HDR_RESP: gethdr_e = 2;
pub const gethdr_e_HDR_OBJ: gethdr_e = 3;
pub const gethdr_e_HDR_BEREQ: gethdr_e = 4;
pub const gethdr_e_HDR_BERESP: gethdr_e = 5;
#[doc = " Getting hold of the various struct http"]
pub type gethdr_e = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gethdr_s {
    pub where_: gethdr_e,
    pub what: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_gethdr_s() {
    assert_eq!(
        ::std::mem::size_of::<gethdr_s>(),
        16usize,
        concat!("Size of: ", stringify!(gethdr_s))
    );
    assert_eq!(
        ::std::mem::align_of::<gethdr_s>(),
        8usize,
        concat!("Alignment of ", stringify!(gethdr_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gethdr_s>())).where_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gethdr_s),
            "::",
            stringify!(where_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gethdr_s>())).what as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gethdr_s),
            "::",
            stringify!(what)
        )
    );
}
impl Default for gethdr_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VRT_selecthttp(ctx: *const vrt_ctx, arg1: gethdr_e) -> VCL_HTTP;
}
extern "C" {
    pub fn VRT_GetHdr(ctx: *const vrt_ctx, arg1: VCL_HEADER) -> VCL_STRING;
}
pub const lbody_e_LBODY_SET: lbody_e = 0;
pub const lbody_e_LBODY_ADD: lbody_e = 1;
#[doc = " req related"]
pub type lbody_e = ::std::os::raw::c_uint;
extern "C" {
    pub fn VRT_CacheReqBody(ctx: *const vrt_ctx, maxsize: VCL_BYTES) -> VCL_BYTES;
}
extern "C" {
    pub fn VRT_ban_string(ctx: *const vrt_ctx, arg1: VCL_STRING) -> VCL_STRING;
}
extern "C" {
    pub fn VRT_purge(
        ctx: *const vrt_ctx,
        arg1: VCL_DURATION,
        arg2: VCL_DURATION,
        arg3: VCL_DURATION,
    ) -> VCL_INT;
}
extern "C" {
    pub fn VRT_synth(ctx: *const vrt_ctx, arg1: VCL_INT, arg2: VCL_STRING) -> VCL_VOID;
}
extern "C" {
    pub fn VRT_hit_for_pass(ctx: *const vrt_ctx, arg1: VCL_DURATION) -> VCL_VOID;
}
extern "C" {
    pub fn VRT_ValidHdr(ctx: *const vrt_ctx, arg1: VCL_STRANDS) -> VCL_BOOL;
}
extern "C" {
    pub fn VRT_UnsetHdr(ctx: *const vrt_ctx, arg1: VCL_HEADER) -> VCL_VOID;
}
extern "C" {
    pub fn VRT_SetHdr(
        ctx: *const vrt_ctx,
        arg1: VCL_HEADER,
        pfx: *const ::std::os::raw::c_char,
        arg2: VCL_STRANDS,
    ) -> VCL_VOID;
}
extern "C" {
    pub fn VRT_handling(ctx: *const vrt_ctx, hand: ::std::os::raw::c_uint) -> VCL_VOID;
}
extern "C" {
    pub fn VRT_handled(ctx: *const vrt_ctx) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn VRT_fail(ctx: *const vrt_ctx, fmt: *const ::std::os::raw::c_char, ...) -> VCL_VOID;
}
extern "C" {
    pub fn VRT_hashdata(ctx: *const vrt_ctx, arg1: VCL_STRANDS) -> VCL_VOID;
}
extern "C" {
    pub fn VRT_Rollback(ctx: *const vrt_ctx, arg1: VCL_HTTP) -> VCL_VOID;
}
extern "C" {
    pub fn VRT_synth_strands(ctx: *const vrt_ctx, arg1: VCL_STRANDS) -> VCL_VOID;
}
extern "C" {
    pub fn VRT_synth_blob(ctx: *const vrt_ctx, arg1: VCL_BLOB) -> VCL_VOID;
}
#[doc = " VDI - Director API"]
pub type vdi_healthy_f = ::std::option::Option<
    unsafe extern "C" fn(ctx: *const vrt_ctx, arg1: VCL_BACKEND, arg2: *mut VCL_TIME) -> VCL_BOOL,
>;
pub type vdi_resolve_f = ::std::option::Option<
    unsafe extern "C" fn(ctx: *const vrt_ctx, arg1: VCL_BACKEND) -> VCL_BACKEND,
>;
pub type vdi_gethdrs_f = ::std::option::Option<
    unsafe extern "C" fn(ctx: *const vrt_ctx, arg1: VCL_BACKEND) -> ::std::os::raw::c_int,
>;
pub type vdi_getip_f =
    ::std::option::Option<unsafe extern "C" fn(ctx: *const vrt_ctx, arg1: VCL_BACKEND) -> VCL_IP>;
pub type vdi_finish_f =
    ::std::option::Option<unsafe extern "C" fn(ctx: *const vrt_ctx, arg1: VCL_BACKEND)>;
pub type vdi_http1pipe_f = ::std::option::Option<
    unsafe extern "C" fn(ctx: *const vrt_ctx, arg1: VCL_BACKEND) -> sess_close,
>;
pub type vdi_event_f =
    ::std::option::Option<unsafe extern "C" fn(arg1: VCL_BACKEND, arg2: vcl_event_e)>;
pub type vdi_destroy_f = ::std::option::Option<unsafe extern "C" fn(arg1: VCL_BACKEND)>;
pub type vdi_panic_f =
    ::std::option::Option<unsafe extern "C" fn(arg1: VCL_BACKEND, arg2: *mut vsb)>;
pub type vdi_list_f = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *const vrt_ctx,
        arg1: VCL_BACKEND,
        arg2: *mut vsb,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdi_methods {
    pub magic: ::std::os::raw::c_uint,
    pub type_: *const ::std::os::raw::c_char,
    pub http1pipe: vdi_http1pipe_f,
    pub healthy: vdi_healthy_f,
    pub resolve: vdi_resolve_f,
    pub gethdrs: vdi_gethdrs_f,
    pub getip: vdi_getip_f,
    pub finish: vdi_finish_f,
    pub event: vdi_event_f,
    pub destroy: vdi_destroy_f,
    pub panic: vdi_panic_f,
    pub list: vdi_list_f,
}
#[test]
fn bindgen_test_layout_vdi_methods() {
    assert_eq!(
        ::std::mem::size_of::<vdi_methods>(),
        96usize,
        concat!("Size of: ", stringify!(vdi_methods))
    );
    assert_eq!(
        ::std::mem::align_of::<vdi_methods>(),
        8usize,
        concat!("Alignment of ", stringify!(vdi_methods))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdi_methods>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vdi_methods),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdi_methods>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vdi_methods),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdi_methods>())).http1pipe as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vdi_methods),
            "::",
            stringify!(http1pipe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdi_methods>())).healthy as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vdi_methods),
            "::",
            stringify!(healthy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdi_methods>())).resolve as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vdi_methods),
            "::",
            stringify!(resolve)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdi_methods>())).gethdrs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vdi_methods),
            "::",
            stringify!(gethdrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdi_methods>())).getip as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vdi_methods),
            "::",
            stringify!(getip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdi_methods>())).finish as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vdi_methods),
            "::",
            stringify!(finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdi_methods>())).event as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vdi_methods),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdi_methods>())).destroy as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vdi_methods),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdi_methods>())).panic as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vdi_methods),
            "::",
            stringify!(panic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdi_methods>())).list as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(vdi_methods),
            "::",
            stringify!(list)
        )
    );
}
impl Default for vdi_methods {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct director {
    pub magic: ::std::os::raw::c_uint,
    pub priv_: *mut ::std::os::raw::c_void,
    pub vcl_name: *mut ::std::os::raw::c_char,
    pub vdir: *mut vcldir,
    pub mtx: *mut lock,
}
#[test]
fn bindgen_test_layout_director() {
    assert_eq!(
        ::std::mem::size_of::<director>(),
        40usize,
        concat!("Size of: ", stringify!(director))
    );
    assert_eq!(
        ::std::mem::align_of::<director>(),
        8usize,
        concat!("Alignment of ", stringify!(director))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<director>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<director>())).priv_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<director>())).vcl_name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(vcl_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<director>())).vdir as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(vdir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<director>())).mtx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(director),
            "::",
            stringify!(mtx)
        )
    );
}
impl Default for director {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VRT_Healthy(ctx: *const vrt_ctx, arg1: VCL_BACKEND, arg2: *mut VCL_TIME) -> VCL_BOOL;
}
extern "C" {
    pub fn VRT_SetChanged(arg1: VCL_BACKEND, arg2: VCL_TIME) -> VCL_VOID;
}
extern "C" {
    pub fn VRT_AddDirector(
        ctx: *const vrt_ctx,
        arg1: *const vdi_methods,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> VCL_BACKEND;
}
extern "C" {
    pub fn VRT_DisableDirector(arg1: VCL_BACKEND);
}
extern "C" {
    pub fn VRT_LookupDirector(ctx: *const vrt_ctx, arg1: VCL_STRING) -> VCL_BACKEND;
}
extern "C" {
    pub fn VRT_DelDirector(arg1: *mut VCL_BACKEND);
}
#[doc = " vmod_priv related"]
pub type vmod_priv_fini_f = ::std::option::Option<
    unsafe extern "C" fn(ctx: *const vrt_ctx, arg1: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmod_priv_methods {
    pub magic: ::std::os::raw::c_uint,
    pub type_: *const ::std::os::raw::c_char,
    pub fini: vmod_priv_fini_f,
}
#[test]
fn bindgen_test_layout_vmod_priv_methods() {
    assert_eq!(
        ::std::mem::size_of::<vmod_priv_methods>(),
        24usize,
        concat!("Size of: ", stringify!(vmod_priv_methods))
    );
    assert_eq!(
        ::std::mem::align_of::<vmod_priv_methods>(),
        8usize,
        concat!("Alignment of ", stringify!(vmod_priv_methods))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmod_priv_methods>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_priv_methods),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmod_priv_methods>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_priv_methods),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmod_priv_methods>())).fini as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_priv_methods),
            "::",
            stringify!(fini)
        )
    );
}
impl Default for vmod_priv_methods {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmod_priv {
    pub priv_: *mut ::std::os::raw::c_void,
    pub len: ::std::os::raw::c_long,
    pub methods: *const vmod_priv_methods,
}
#[test]
fn bindgen_test_layout_vmod_priv() {
    assert_eq!(
        ::std::mem::size_of::<vmod_priv>(),
        24usize,
        concat!("Size of: ", stringify!(vmod_priv))
    );
    assert_eq!(
        ::std::mem::align_of::<vmod_priv>(),
        8usize,
        concat!("Alignment of ", stringify!(vmod_priv))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmod_priv>())).priv_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_priv),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmod_priv>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_priv),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmod_priv>())).methods as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vmod_priv),
            "::",
            stringify!(methods)
        )
    );
}
impl Default for vmod_priv {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VRT_priv_fini(ctx: *const vrt_ctx, p: *const vmod_priv);
}
extern "C" {
    pub fn VRT_priv_task(
        ctx: *const vrt_ctx,
        vmod_id: *const ::std::os::raw::c_void,
    ) -> *mut vmod_priv;
}
extern "C" {
    pub fn VRT_priv_task_get(
        ctx: *const vrt_ctx,
        vmod_id: *const ::std::os::raw::c_void,
    ) -> *mut vmod_priv;
}
extern "C" {
    pub fn VRT_priv_top(
        ctx: *const vrt_ctx,
        vmod_id: *const ::std::os::raw::c_void,
    ) -> *mut vmod_priv;
}
extern "C" {
    pub fn VRT_priv_top_get(
        ctx: *const vrt_ctx,
        vmod_id: *const ::std::os::raw::c_void,
    ) -> *mut vmod_priv;
}
extern "C" {
    #[doc = " VSM and VSC"]
    pub fn VRT_VSM_Cluster_New(ctx: *const vrt_ctx, arg1: size_t) -> *mut vsmw_cluster;
}
extern "C" {
    pub fn VRT_VSM_Cluster_Destroy(ctx: *const vrt_ctx, arg1: *mut *mut vsmw_cluster);
}
extern "C" {
    pub fn VRT_VSC_Alloc(
        arg1: *mut vsmw_cluster,
        arg2: *mut *mut vsc_seg,
        arg3: *const ::std::os::raw::c_char,
        arg4: size_t,
        arg5: *const ::std::os::raw::c_uchar,
        arg6: size_t,
        arg7: *const ::std::os::raw::c_char,
        arg8: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn VRT_VSC_Destroy(arg1: *const ::std::os::raw::c_char, arg2: *mut vsc_seg);
}
extern "C" {
    pub fn VRT_VSC_Hide(arg1: *const vsc_seg);
}
extern "C" {
    pub fn VRT_VSC_Reveal(arg1: *const vsc_seg);
}
extern "C" {
    pub fn VRT_VSC_Overhead(arg1: size_t) -> size_t;
}
#[doc = " API to restrict the VCL in various ways"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vclref {
    _unused: [u8; 0],
}
extern "C" {
    pub fn VRT_VCL_Prevent_Cold(
        ctx: *const vrt_ctx,
        arg1: *const ::std::os::raw::c_char,
    ) -> *mut vclref;
}
extern "C" {
    pub fn VRT_VCL_Allow_Cold(arg1: *mut *mut vclref);
}
extern "C" {
    pub fn VRT_VCL_Prevent_Discard(
        ctx: *const vrt_ctx,
        arg1: *const ::std::os::raw::c_char,
    ) -> *mut vclref;
}
extern "C" {
    pub fn VRT_VCL_Allow_Discard(arg1: *mut *mut vclref);
}
extern "C" {
    #[doc = " Deprecated interfaces, do not use, they will disappear at some point."]
    pub fn VRT_synth_page(ctx: *const vrt_ctx, arg1: VCL_STRANDS) -> VCL_VOID;
}
extern "C" {
    pub fn VRT_Stv(nm: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn VAS_errtxt(e: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
pub const vas_e_VAS_WRONG: vas_e = 0;
pub const vas_e_VAS_MISSING: vas_e = 1;
pub const vas_e_VAS_ASSERT: vas_e = 2;
pub const vas_e_VAS_INCOMPLETE: vas_e = 3;
pub const vas_e_VAS_VCL: vas_e = 4;
pub type vas_e = ::std::os::raw::c_uint;
pub type vas_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: vas_e,
    ),
>;
extern "C" {
    pub static mut VAS_Fail_Func: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
            arg4: *const ::std::os::raw::c_char,
            arg5: vas_e,
        ),
    >;
}
extern "C" {
    pub fn VAS_Fail(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: vas_e,
    );
}
pub const VSL_tag_e_SLT__Bogus: VSL_tag_e = 0;
pub const VSL_tag_e_SLT_Debug: VSL_tag_e = 1;
pub const VSL_tag_e_SLT_Error: VSL_tag_e = 2;
pub const VSL_tag_e_SLT_CLI: VSL_tag_e = 3;
pub const VSL_tag_e_SLT_SessOpen: VSL_tag_e = 4;
pub const VSL_tag_e_SLT_SessClose: VSL_tag_e = 5;
pub const VSL_tag_e_SLT_BackendOpen: VSL_tag_e = 6;
pub const VSL_tag_e_SLT_BackendReuse: VSL_tag_e = 7;
pub const VSL_tag_e_SLT_BackendClose: VSL_tag_e = 8;
pub const VSL_tag_e_SLT_HttpGarbage: VSL_tag_e = 9;
pub const VSL_tag_e_SLT_Proxy: VSL_tag_e = 10;
pub const VSL_tag_e_SLT_ProxyGarbage: VSL_tag_e = 11;
pub const VSL_tag_e_SLT_Backend: VSL_tag_e = 12;
pub const VSL_tag_e_SLT_Length: VSL_tag_e = 13;
pub const VSL_tag_e_SLT_FetchError: VSL_tag_e = 14;
pub const VSL_tag_e_SLT_ReqMethod: VSL_tag_e = 15;
pub const VSL_tag_e_SLT_ReqURL: VSL_tag_e = 16;
pub const VSL_tag_e_SLT_ReqProtocol: VSL_tag_e = 17;
pub const VSL_tag_e_SLT_ReqStatus: VSL_tag_e = 18;
pub const VSL_tag_e_SLT_ReqReason: VSL_tag_e = 19;
pub const VSL_tag_e_SLT_ReqHeader: VSL_tag_e = 20;
pub const VSL_tag_e_SLT_ReqUnset: VSL_tag_e = 21;
pub const VSL_tag_e_SLT_ReqLost: VSL_tag_e = 22;
pub const VSL_tag_e_SLT_RespMethod: VSL_tag_e = 23;
pub const VSL_tag_e_SLT_RespURL: VSL_tag_e = 24;
pub const VSL_tag_e_SLT_RespProtocol: VSL_tag_e = 25;
pub const VSL_tag_e_SLT_RespStatus: VSL_tag_e = 26;
pub const VSL_tag_e_SLT_RespReason: VSL_tag_e = 27;
pub const VSL_tag_e_SLT_RespHeader: VSL_tag_e = 28;
pub const VSL_tag_e_SLT_RespUnset: VSL_tag_e = 29;
pub const VSL_tag_e_SLT_RespLost: VSL_tag_e = 30;
pub const VSL_tag_e_SLT_BereqMethod: VSL_tag_e = 31;
pub const VSL_tag_e_SLT_BereqURL: VSL_tag_e = 32;
pub const VSL_tag_e_SLT_BereqProtocol: VSL_tag_e = 33;
pub const VSL_tag_e_SLT_BereqStatus: VSL_tag_e = 34;
pub const VSL_tag_e_SLT_BereqReason: VSL_tag_e = 35;
pub const VSL_tag_e_SLT_BereqHeader: VSL_tag_e = 36;
pub const VSL_tag_e_SLT_BereqUnset: VSL_tag_e = 37;
pub const VSL_tag_e_SLT_BereqLost: VSL_tag_e = 38;
pub const VSL_tag_e_SLT_BerespMethod: VSL_tag_e = 39;
pub const VSL_tag_e_SLT_BerespURL: VSL_tag_e = 40;
pub const VSL_tag_e_SLT_BerespProtocol: VSL_tag_e = 41;
pub const VSL_tag_e_SLT_BerespStatus: VSL_tag_e = 42;
pub const VSL_tag_e_SLT_BerespReason: VSL_tag_e = 43;
pub const VSL_tag_e_SLT_BerespHeader: VSL_tag_e = 44;
pub const VSL_tag_e_SLT_BerespUnset: VSL_tag_e = 45;
pub const VSL_tag_e_SLT_BerespLost: VSL_tag_e = 46;
pub const VSL_tag_e_SLT_ObjMethod: VSL_tag_e = 47;
pub const VSL_tag_e_SLT_ObjURL: VSL_tag_e = 48;
pub const VSL_tag_e_SLT_ObjProtocol: VSL_tag_e = 49;
pub const VSL_tag_e_SLT_ObjStatus: VSL_tag_e = 50;
pub const VSL_tag_e_SLT_ObjReason: VSL_tag_e = 51;
pub const VSL_tag_e_SLT_ObjHeader: VSL_tag_e = 52;
pub const VSL_tag_e_SLT_ObjUnset: VSL_tag_e = 53;
pub const VSL_tag_e_SLT_ObjLost: VSL_tag_e = 54;
pub const VSL_tag_e_SLT_BogoHeader: VSL_tag_e = 55;
pub const VSL_tag_e_SLT_LostHeader: VSL_tag_e = 56;
pub const VSL_tag_e_SLT_TTL: VSL_tag_e = 57;
pub const VSL_tag_e_SLT_Fetch_Body: VSL_tag_e = 58;
pub const VSL_tag_e_SLT_VCL_acl: VSL_tag_e = 59;
pub const VSL_tag_e_SLT_VCL_call: VSL_tag_e = 60;
pub const VSL_tag_e_SLT_VCL_trace: VSL_tag_e = 61;
pub const VSL_tag_e_SLT_VCL_return: VSL_tag_e = 62;
pub const VSL_tag_e_SLT_ReqStart: VSL_tag_e = 63;
pub const VSL_tag_e_SLT_Hit: VSL_tag_e = 64;
pub const VSL_tag_e_SLT_HitPass: VSL_tag_e = 65;
pub const VSL_tag_e_SLT_ExpBan: VSL_tag_e = 66;
pub const VSL_tag_e_SLT_ExpKill: VSL_tag_e = 67;
pub const VSL_tag_e_SLT_WorkThread: VSL_tag_e = 68;
pub const VSL_tag_e_SLT_ESI_xmlerror: VSL_tag_e = 69;
pub const VSL_tag_e_SLT_Hash: VSL_tag_e = 70;
pub const VSL_tag_e_SLT_Backend_health: VSL_tag_e = 71;
pub const VSL_tag_e_SLT_VCL_Log: VSL_tag_e = 72;
pub const VSL_tag_e_SLT_VCL_Error: VSL_tag_e = 73;
pub const VSL_tag_e_SLT_Gzip: VSL_tag_e = 74;
pub const VSL_tag_e_SLT_Link: VSL_tag_e = 75;
pub const VSL_tag_e_SLT_Begin: VSL_tag_e = 76;
pub const VSL_tag_e_SLT_End: VSL_tag_e = 77;
pub const VSL_tag_e_SLT_VSL: VSL_tag_e = 78;
pub const VSL_tag_e_SLT_Storage: VSL_tag_e = 79;
pub const VSL_tag_e_SLT_Timestamp: VSL_tag_e = 80;
pub const VSL_tag_e_SLT_ReqAcct: VSL_tag_e = 81;
pub const VSL_tag_e_SLT_PipeAcct: VSL_tag_e = 82;
pub const VSL_tag_e_SLT_BereqAcct: VSL_tag_e = 83;
pub const VSL_tag_e_SLT_VfpAcct: VSL_tag_e = 84;
pub const VSL_tag_e_SLT_Witness: VSL_tag_e = 85;
pub const VSL_tag_e_SLT_BackendStart: VSL_tag_e = 86;
pub const VSL_tag_e_SLT_H2RxHdr: VSL_tag_e = 87;
pub const VSL_tag_e_SLT_H2RxBody: VSL_tag_e = 88;
pub const VSL_tag_e_SLT_H2TxHdr: VSL_tag_e = 89;
pub const VSL_tag_e_SLT_H2TxBody: VSL_tag_e = 90;
pub const VSL_tag_e_SLT_HitMiss: VSL_tag_e = 91;
pub const VSL_tag_e_SLT_Filters: VSL_tag_e = 92;
pub const VSL_tag_e_SLT_SessError: VSL_tag_e = 93;
pub const VSL_tag_e_SLT_VCL_use: VSL_tag_e = 94;
pub const VSL_tag_e_SLT_Notice: VSL_tag_e = 95;
pub const VSL_tag_e_SLT_VdpAcct: VSL_tag_e = 96;
pub const VSL_tag_e_SLT__Reserved: VSL_tag_e = 254;
pub const VSL_tag_e_SLT__Batch: VSL_tag_e = 255;
pub type VSL_tag_e = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct body_status {
    pub name: *const ::std::os::raw::c_char,
    pub nbr: ::std::os::raw::c_int,
    pub avail: ::std::os::raw::c_int,
    pub length_known: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_body_status() {
    assert_eq!(
        ::std::mem::size_of::<body_status>(),
        24usize,
        concat!("Size of: ", stringify!(body_status))
    );
    assert_eq!(
        ::std::mem::align_of::<body_status>(),
        8usize,
        concat!("Alignment of ", stringify!(body_status))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<body_status>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(body_status),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<body_status>())).nbr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(body_status),
            "::",
            stringify!(nbr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<body_status>())).avail as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(body_status),
            "::",
            stringify!(avail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<body_status>())).length_known as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(body_status),
            "::",
            stringify!(length_known)
        )
    );
}
impl Default for body_status {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static BS_NONE: [body_status; 1usize];
}
extern "C" {
    pub static BS_ERROR: [body_status; 1usize];
}
extern "C" {
    pub static BS_CHUNKED: [body_status; 1usize];
}
extern "C" {
    pub static BS_LENGTH: [body_status; 1usize];
}
extern "C" {
    pub static BS_EOF: [body_status; 1usize];
}
extern "C" {
    pub static BS_TAKEN: [body_status; 1usize];
}
extern "C" {
    pub static BS_CACHED: [body_status; 1usize];
}
pub type body_status_t = *const body_status;
pub type hdr_t = *const ::std::os::raw::c_char;
pub const sess_close_SC_NULL: sess_close = 0;
pub const sess_close_SC_REM_CLOSE: sess_close = 1;
pub const sess_close_SC_REQ_CLOSE: sess_close = 2;
pub const sess_close_SC_REQ_HTTP10: sess_close = 3;
pub const sess_close_SC_RX_BAD: sess_close = 4;
pub const sess_close_SC_RX_BODY: sess_close = 5;
pub const sess_close_SC_RX_JUNK: sess_close = 6;
pub const sess_close_SC_RX_OVERFLOW: sess_close = 7;
pub const sess_close_SC_RX_TIMEOUT: sess_close = 8;
pub const sess_close_SC_RX_CLOSE_IDLE: sess_close = 9;
pub const sess_close_SC_TX_PIPE: sess_close = 10;
pub const sess_close_SC_TX_ERROR: sess_close = 11;
pub const sess_close_SC_TX_EOF: sess_close = 12;
pub const sess_close_SC_RESP_CLOSE: sess_close = 13;
pub const sess_close_SC_OVERLOAD: sess_close = 14;
pub const sess_close_SC_PIPE_OVERFLOW: sess_close = 15;
pub const sess_close_SC_RANGE_SHORT: sess_close = 16;
pub const sess_close_SC_REQ_HTTP20: sess_close = 17;
pub const sess_close_SC_VCL_FAILURE: sess_close = 18;
pub type sess_close = i32;
pub const HTTP_HDR_METHOD: ::std::os::raw::c_uint = 0;
pub const HTTP_HDR_URL: ::std::os::raw::c_uint = 1;
pub const HTTP_HDR_PROTO: ::std::os::raw::c_uint = 2;
pub const HTTP_HDR_STATUS: ::std::os::raw::c_uint = 3;
pub const HTTP_HDR_REASON: ::std::os::raw::c_uint = 4;
pub const HTTP_HDR_FIRST: ::std::os::raw::c_uint = 5;
pub const HTTP_HDR_UNSET: ::std::os::raw::c_uint = 6;
pub const HTTP_HDR_LOST: ::std::os::raw::c_uint = 7;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ban {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ban_proto {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cli {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct listen_sock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mempool {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct objhead {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pool {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct req_step {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct transport {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vcf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VSC_lck {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VSC_main_wrk {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct worker_priv {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock {
    pub priv_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_lock() {
    assert_eq!(
        ::std::mem::size_of::<lock>(),
        8usize,
        concat!("Size of: ", stringify!(lock))
    );
    assert_eq!(
        ::std::mem::align_of::<lock>(),
        8usize,
        concat!("Alignment of ", stringify!(lock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lock>())).priv_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lock),
            "::",
            stringify!(priv_)
        )
    );
}
impl Default for lock {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ws {
    pub magic: ::std::os::raw::c_uint,
    pub id: [::std::os::raw::c_char; 4usize],
    pub s: *mut ::std::os::raw::c_char,
    pub f: *mut ::std::os::raw::c_char,
    pub r: *mut ::std::os::raw::c_char,
    pub e: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ws() {
    assert_eq!(
        ::std::mem::size_of::<ws>(),
        40usize,
        concat!("Size of: ", stringify!(ws))
    );
    assert_eq!(
        ::std::mem::align_of::<ws>(),
        8usize,
        concat!("Alignment of ", stringify!(ws))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ws>())).magic as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ws), "::", stringify!(magic))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ws>())).id as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(ws), "::", stringify!(id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ws>())).s as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ws), "::", stringify!(s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ws>())).f as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(ws), "::", stringify!(f))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ws>())).r as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(ws), "::", stringify!(r))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ws>())).e as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(ws), "::", stringify!(e))
    );
}
impl Default for ws {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct http {
    pub magic: ::std::os::raw::c_uint,
    pub shd: u16,
    pub hd: *mut txt,
    pub hdf: *mut ::std::os::raw::c_uchar,
    pub nhd: u16,
    pub logtag: VSL_tag_e,
    pub vsl: *mut vsl_log,
    pub ws: *mut ws,
    pub status: u16,
    pub protover: u8,
}
#[test]
fn bindgen_test_layout_http() {
    assert_eq!(
        ::std::mem::size_of::<http>(),
        56usize,
        concat!("Size of: ", stringify!(http))
    );
    assert_eq!(
        ::std::mem::align_of::<http>(),
        8usize,
        concat!("Alignment of ", stringify!(http))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<http>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(http),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<http>())).shd as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(http), "::", stringify!(shd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<http>())).hd as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(http), "::", stringify!(hd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<http>())).hdf as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(http), "::", stringify!(hdf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<http>())).nhd as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(http), "::", stringify!(nhd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<http>())).logtag as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(http),
            "::",
            stringify!(logtag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<http>())).vsl as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(http), "::", stringify!(vsl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<http>())).ws as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(http), "::", stringify!(ws))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<http>())).status as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(http),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<http>())).protover as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(http),
            "::",
            stringify!(protover)
        )
    );
}
impl Default for http {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct acct_req {
    pub req_hdrbytes: u64,
    pub req_bodybytes: u64,
    pub resp_hdrbytes: u64,
    pub resp_bodybytes: u64,
}
#[test]
fn bindgen_test_layout_acct_req() {
    assert_eq!(
        ::std::mem::size_of::<acct_req>(),
        32usize,
        concat!("Size of: ", stringify!(acct_req))
    );
    assert_eq!(
        ::std::mem::align_of::<acct_req>(),
        8usize,
        concat!("Alignment of ", stringify!(acct_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<acct_req>())).req_hdrbytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acct_req),
            "::",
            stringify!(req_hdrbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<acct_req>())).req_bodybytes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(acct_req),
            "::",
            stringify!(req_bodybytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<acct_req>())).resp_hdrbytes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(acct_req),
            "::",
            stringify!(resp_hdrbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<acct_req>())).resp_bodybytes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(acct_req),
            "::",
            stringify!(resp_bodybytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct acct_bereq {
    pub bereq_hdrbytes: u64,
    pub bereq_bodybytes: u64,
    pub beresp_hdrbytes: u64,
    pub beresp_bodybytes: u64,
}
#[test]
fn bindgen_test_layout_acct_bereq() {
    assert_eq!(
        ::std::mem::size_of::<acct_bereq>(),
        32usize,
        concat!("Size of: ", stringify!(acct_bereq))
    );
    assert_eq!(
        ::std::mem::align_of::<acct_bereq>(),
        8usize,
        concat!("Alignment of ", stringify!(acct_bereq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<acct_bereq>())).bereq_hdrbytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(acct_bereq),
            "::",
            stringify!(bereq_hdrbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<acct_bereq>())).bereq_bodybytes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(acct_bereq),
            "::",
            stringify!(bereq_bodybytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<acct_bereq>())).beresp_hdrbytes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(acct_bereq),
            "::",
            stringify!(beresp_hdrbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<acct_bereq>())).beresp_bodybytes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(acct_bereq),
            "::",
            stringify!(beresp_bodybytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsl_log {
    pub wlb: *mut u32,
    pub wlp: *mut u32,
    pub wle: *mut u32,
    pub wlr: ::std::os::raw::c_uint,
    pub wid: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_vsl_log() {
    assert_eq!(
        ::std::mem::size_of::<vsl_log>(),
        32usize,
        concat!("Size of: ", stringify!(vsl_log))
    );
    assert_eq!(
        ::std::mem::align_of::<vsl_log>(),
        8usize,
        concat!("Alignment of ", stringify!(vsl_log))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vsl_log>())).wlb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vsl_log),
            "::",
            stringify!(wlb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vsl_log>())).wlp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vsl_log),
            "::",
            stringify!(wlp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vsl_log>())).wle as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vsl_log),
            "::",
            stringify!(wle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vsl_log>())).wlr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vsl_log),
            "::",
            stringify!(wlr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vsl_log>())).wid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(vsl_log),
            "::",
            stringify!(wid)
        )
    );
}
impl Default for vsl_log {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vrt_privs {
    pub rbh_root: *mut vrt_priv,
}
#[test]
fn bindgen_test_layout_vrt_privs() {
    assert_eq!(
        ::std::mem::size_of::<vrt_privs>(),
        8usize,
        concat!("Size of: ", stringify!(vrt_privs))
    );
    assert_eq!(
        ::std::mem::align_of::<vrt_privs>(),
        8usize,
        concat!("Alignment of ", stringify!(vrt_privs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vrt_privs>())).rbh_root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vrt_privs),
            "::",
            stringify!(rbh_root)
        )
    );
}
impl Default for vrt_privs {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type task_func_t = ::std::option::Option<
    unsafe extern "C" fn(wrk: *mut worker, priv_: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pool_task {
    pub list: pool_task__bindgen_ty_1,
    pub func: task_func_t,
    pub priv_: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pool_task__bindgen_ty_1 {
    pub vtqe_next: *mut pool_task,
    pub vtqe_prev: *mut *mut pool_task,
}
#[test]
fn bindgen_test_layout_pool_task__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pool_task__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(pool_task__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pool_task__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pool_task__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pool_task__bindgen_ty_1>())).vtqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pool_task__bindgen_ty_1),
            "::",
            stringify!(vtqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pool_task__bindgen_ty_1>())).vtqe_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pool_task__bindgen_ty_1),
            "::",
            stringify!(vtqe_prev)
        )
    );
}
impl Default for pool_task__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_pool_task() {
    assert_eq!(
        ::std::mem::size_of::<pool_task>(),
        32usize,
        concat!("Size of: ", stringify!(pool_task))
    );
    assert_eq!(
        ::std::mem::align_of::<pool_task>(),
        8usize,
        concat!("Alignment of ", stringify!(pool_task))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pool_task>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pool_task),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pool_task>())).func as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pool_task),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pool_task>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pool_task),
            "::",
            stringify!(priv_)
        )
    );
}
impl Default for pool_task {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const task_prio_TASK_QUEUE_BO: task_prio = 0;
pub const task_prio_TASK_QUEUE_RUSH: task_prio = 1;
pub const task_prio_TASK_QUEUE_REQ: task_prio = 2;
pub const task_prio_TASK_QUEUE_STR: task_prio = 3;
pub const task_prio_TASK_QUEUE_VCA: task_prio = 4;
pub const task_prio_TASK_QUEUE__END: task_prio = 5;
pub type task_prio = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct worker {
    pub magic: ::std::os::raw::c_uint,
    pub strangelove: ::std::os::raw::c_int,
    pub wpriv: *mut worker_priv,
    pub pool: *mut pool,
    pub stats: *mut VSC_main_wrk,
    pub vsl: *mut vsl_log,
    pub task: [pool_task; 1usize],
    pub lastused: vtim_real,
    pub v1l: *mut v1l,
    pub cond: pthread_cond_t,
    pub aws: [ws; 1usize],
    pub cur_method: ::std::os::raw::c_uint,
    pub seen_methods: ::std::os::raw::c_uint,
    pub handling: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_worker() {
    assert_eq!(
        ::std::mem::size_of::<worker>(),
        192usize,
        concat!("Size of: ", stringify!(worker))
    );
    assert_eq!(
        ::std::mem::align_of::<worker>(),
        8usize,
        concat!("Alignment of ", stringify!(worker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<worker>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<worker>())).strangelove as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(strangelove)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<worker>())).wpriv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(wpriv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<worker>())).pool as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<worker>())).stats as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<worker>())).vsl as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(vsl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<worker>())).task as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(task)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<worker>())).lastused as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(lastused)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<worker>())).v1l as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(v1l)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<worker>())).cond as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<worker>())).aws as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(aws)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<worker>())).cur_method as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(cur_method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<worker>())).seen_methods as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(seen_methods)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<worker>())).handling as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(worker),
            "::",
            stringify!(handling)
        )
    );
}
impl Default for worker {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct storeobj {
    pub stevedore: *const stevedore,
    pub priv_: *mut ::std::os::raw::c_void,
    pub priv2: usize,
}
#[test]
fn bindgen_test_layout_storeobj() {
    assert_eq!(
        ::std::mem::size_of::<storeobj>(),
        24usize,
        concat!("Size of: ", stringify!(storeobj))
    );
    assert_eq!(
        ::std::mem::align_of::<storeobj>(),
        8usize,
        concat!("Alignment of ", stringify!(storeobj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<storeobj>())).stevedore as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(storeobj),
            "::",
            stringify!(stevedore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<storeobj>())).priv_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(storeobj),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<storeobj>())).priv2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(storeobj),
            "::",
            stringify!(priv2)
        )
    );
}
impl Default for storeobj {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const boc_state_e_BOS_INVALID: boc_state_e = 0;
pub const boc_state_e_BOS_REQ_DONE: boc_state_e = 1;
pub const boc_state_e_BOS_PREP_STREAM: boc_state_e = 2;
pub const boc_state_e_BOS_STREAM: boc_state_e = 3;
pub const boc_state_e_BOS_FINISHED: boc_state_e = 4;
pub const boc_state_e_BOS_FAILED: boc_state_e = 5;
pub type boc_state_e = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct boc {
    pub magic: ::std::os::raw::c_uint,
    pub refcount: ::std::os::raw::c_uint,
    pub mtx: lock,
    pub cond: pthread_cond_t,
    pub stevedore_priv: *mut ::std::os::raw::c_void,
    pub state: boc_state_e,
    pub vary: *mut u8,
    pub len_so_far: u64,
}
#[test]
fn bindgen_test_layout_boc() {
    assert_eq!(
        ::std::mem::size_of::<boc>(),
        96usize,
        concat!("Size of: ", stringify!(boc))
    );
    assert_eq!(
        ::std::mem::align_of::<boc>(),
        8usize,
        concat!("Alignment of ", stringify!(boc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boc>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(boc),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boc>())).refcount as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(boc),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boc>())).mtx as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(boc), "::", stringify!(mtx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boc>())).cond as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(boc), "::", stringify!(cond))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boc>())).stevedore_priv as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(boc),
            "::",
            stringify!(stevedore_priv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boc>())).state as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(boc),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boc>())).vary as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(boc), "::", stringify!(vary))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boc>())).len_so_far as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(boc),
            "::",
            stringify!(len_so_far)
        )
    );
}
impl Default for boc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const obj_attr_OA_LEN: obj_attr = 0;
pub const obj_attr_OA_VXID: obj_attr = 1;
pub const obj_attr_OA_FLAGS: obj_attr = 2;
pub const obj_attr_OA_GZIPBITS: obj_attr = 3;
pub const obj_attr_OA_LASTMODIFIED: obj_attr = 4;
pub const obj_attr_OA_VARY: obj_attr = 5;
pub const obj_attr_OA_HEADERS: obj_attr = 6;
pub const obj_attr_OA_ESIDATA: obj_attr = 7;
pub const obj_attr_OA__MAX: obj_attr = 8;
pub type obj_attr = ::std::os::raw::c_uint;
pub const obj_flags_OF_GZIPED: obj_flags = 2;
pub const obj_flags_OF_CHGCE: obj_flags = 4;
pub const obj_flags_OF_IMSCAND: obj_flags = 8;
pub const obj_flags_OF_ESIPROC: obj_flags = 16;
pub type obj_flags = ::std::os::raw::c_uint;
pub const oc_flags_OC_F_PURGED: oc_flags = 1;
pub const oc_flags_OC_F_BUSY: oc_flags = 2;
pub const oc_flags_OC_F_HFM: oc_flags = 4;
pub const oc_flags_OC_F_HFP: oc_flags = 8;
pub const oc_flags_OC_F_CANCEL: oc_flags = 16;
pub const oc_flags_OC_F_PRIVATE: oc_flags = 32;
pub const oc_flags_OC_F_FAILED: oc_flags = 64;
pub const oc_flags_OC_F_DYING: oc_flags = 128;
pub type oc_flags = ::std::os::raw::c_uint;
pub const oc_exp_flags_OC_EF_POSTED: oc_exp_flags = 2;
pub const oc_exp_flags_OC_EF_REFD: oc_exp_flags = 4;
pub const oc_exp_flags_OC_EF_MOVE: oc_exp_flags = 8;
pub const oc_exp_flags_OC_EF_INSERT: oc_exp_flags = 16;
pub const oc_exp_flags_OC_EF_REMOVE: oc_exp_flags = 32;
pub const oc_exp_flags_OC_EF_NEW: oc_exp_flags = 64;
pub type oc_exp_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct objcore {
    pub magic: ::std::os::raw::c_uint,
    pub refcnt: ::std::os::raw::c_int,
    pub stobj: [storeobj; 1usize],
    pub objhead: *mut objhead,
    pub boc: *mut boc,
    pub timer_when: vtim_real,
    pub hits: VCL_INT,
    pub t_origin: vtim_real,
    pub ttl: f32,
    pub grace: f32,
    pub keep: f32,
    pub flags: u8,
    pub exp_flags: u8,
    pub oa_present: u16,
    pub timer_idx: ::std::os::raw::c_uint,
    pub last_lru: vtim_real,
    pub hsh_list: objcore__bindgen_ty_1,
    pub lru_list: objcore__bindgen_ty_2,
    pub ban_list: objcore__bindgen_ty_3,
    pub exp_list: objcore__bindgen_ty_4,
    pub ban: *mut ban,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct objcore__bindgen_ty_1 {
    pub vtqe_next: *mut objcore,
    pub vtqe_prev: *mut *mut objcore,
}
#[test]
fn bindgen_test_layout_objcore__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<objcore__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(objcore__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<objcore__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(objcore__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore__bindgen_ty_1>())).vtqe_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore__bindgen_ty_1),
            "::",
            stringify!(vtqe_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore__bindgen_ty_1>())).vtqe_prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore__bindgen_ty_1),
            "::",
            stringify!(vtqe_prev)
        )
    );
}
impl Default for objcore__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct objcore__bindgen_ty_2 {
    pub vtqe_next: *mut objcore,
    pub vtqe_prev: *mut *mut objcore,
}
#[test]
fn bindgen_test_layout_objcore__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<objcore__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(objcore__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<objcore__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(objcore__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore__bindgen_ty_2>())).vtqe_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore__bindgen_ty_2),
            "::",
            stringify!(vtqe_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore__bindgen_ty_2>())).vtqe_prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore__bindgen_ty_2),
            "::",
            stringify!(vtqe_prev)
        )
    );
}
impl Default for objcore__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct objcore__bindgen_ty_3 {
    pub vtqe_next: *mut objcore,
    pub vtqe_prev: *mut *mut objcore,
}
#[test]
fn bindgen_test_layout_objcore__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<objcore__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(objcore__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<objcore__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(objcore__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore__bindgen_ty_3>())).vtqe_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore__bindgen_ty_3),
            "::",
            stringify!(vtqe_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore__bindgen_ty_3>())).vtqe_prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore__bindgen_ty_3),
            "::",
            stringify!(vtqe_prev)
        )
    );
}
impl Default for objcore__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct objcore__bindgen_ty_4 {
    pub vstqe_next: *mut objcore,
}
#[test]
fn bindgen_test_layout_objcore__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<objcore__bindgen_ty_4>(),
        8usize,
        concat!("Size of: ", stringify!(objcore__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<objcore__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(objcore__bindgen_ty_4))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<objcore__bindgen_ty_4>())).vstqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore__bindgen_ty_4),
            "::",
            stringify!(vstqe_next)
        )
    );
}
impl Default for objcore__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_objcore() {
    assert_eq!(
        ::std::mem::size_of::<objcore>(),
        168usize,
        concat!("Size of: ", stringify!(objcore))
    );
    assert_eq!(
        ::std::mem::align_of::<objcore>(),
        8usize,
        concat!("Alignment of ", stringify!(objcore))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore>())).refcnt as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore>())).stobj as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(stobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore>())).objhead as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(objhead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore>())).boc as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(boc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore>())).timer_when as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(timer_when)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore>())).hits as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(hits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore>())).t_origin as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(t_origin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore>())).ttl as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore>())).grace as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(grace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore>())).keep as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(keep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore>())).flags as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore>())).exp_flags as *const _ as usize },
        85usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(exp_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore>())).oa_present as *const _ as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(oa_present)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore>())).timer_idx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(timer_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore>())).last_lru as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(last_lru)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore>())).hsh_list as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(hsh_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore>())).lru_list as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(lru_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore>())).ban_list as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(ban_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore>())).exp_list as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(exp_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<objcore>())).ban as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(objcore),
            "::",
            stringify!(ban)
        )
    );
}
impl Default for objcore {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const director_state_e_DIR_S_NULL: director_state_e = 0;
pub const director_state_e_DIR_S_HDRS: director_state_e = 1;
pub const director_state_e_DIR_S_BODY: director_state_e = 2;
pub type director_state_e = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct busyobj {
    pub magic: ::std::os::raw::c_uint,
    pub end: *mut ::std::os::raw::c_char,
    pub retries: ::std::os::raw::c_uint,
    pub req: *mut req,
    pub sp: *mut sess,
    pub wrk: *mut worker,
    pub vfc: *mut vfp_ctx,
    pub vfp_filter_list: *const ::std::os::raw::c_char,
    pub ws: [ws; 1usize],
    pub ws_bo: usize,
    pub bereq0: *mut http,
    pub bereq: *mut http,
    pub beresp: *mut http,
    pub bereq_body: *mut objcore,
    pub stale_oc: *mut objcore,
    pub fetch_objcore: *mut objcore,
    pub no_retry: *const ::std::os::raw::c_char,
    pub htc: *mut http_conn,
    pub fetch_task: [pool_task; 1usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub connect_timeout: vtim_dur,
    pub first_byte_timeout: vtim_dur,
    pub between_bytes_timeout: vtim_dur,
    pub t_first: vtim_real,
    pub t_prev: vtim_real,
    pub acct: acct_bereq,
    pub storage: *const stevedore,
    pub director_req: *const director,
    pub director_resp: *const director,
    pub director_state: director_state_e,
    pub vcl: *mut vcl,
    pub vsl: [vsl_log; 1usize],
    pub digest: [u8; 32usize],
    pub privs: [vrt_privs; 1usize],
    pub err_code: u16,
    pub err_reason: *const ::std::os::raw::c_char,
    pub client_identity: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_busyobj() {
    assert_eq!(
        ::std::mem::size_of::<busyobj>(),
        424usize,
        concat!("Size of: ", stringify!(busyobj))
    );
    assert_eq!(
        ::std::mem::align_of::<busyobj>(),
        8usize,
        concat!("Alignment of ", stringify!(busyobj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).retries as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(retries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).req as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).sp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).wrk as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(wrk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).vfc as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(vfc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).vfp_filter_list as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(vfp_filter_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).ws as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(ws)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).ws_bo as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(ws_bo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).bereq0 as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(bereq0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).bereq as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(bereq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).beresp as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(beresp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).bereq_body as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(bereq_body)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).stale_oc as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(stale_oc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).fetch_objcore as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(fetch_objcore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).no_retry as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(no_retry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).htc as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(htc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).fetch_task as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(fetch_task)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).connect_timeout as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(connect_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).first_byte_timeout as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(first_byte_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).between_bytes_timeout as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(between_bytes_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).t_first as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(t_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).t_prev as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(t_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).acct as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(acct)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).storage as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).director_req as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(director_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).director_resp as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(director_resp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).director_state as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(director_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).vcl as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(vcl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).vsl as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(vsl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).digest as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(digest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).privs as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(privs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).err_code as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(err_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).err_reason as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(err_reason)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<busyobj>())).client_identity as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(busyobj),
            "::",
            stringify!(client_identity)
        )
    );
}
impl Default for busyobj {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl busyobj {
    #[inline]
    pub fn do_esi(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_esi(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn do_gzip(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_gzip(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn do_gunzip(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_gunzip(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn do_stream(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_stream(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uncacheable(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uncacheable(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn was_304(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_was_304(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_bgfetch(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_bgfetch(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_hitmiss(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_hitmiss(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_hitpass(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_hitpass(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        do_esi: ::std::os::raw::c_uint,
        do_gzip: ::std::os::raw::c_uint,
        do_gunzip: ::std::os::raw::c_uint,
        do_stream: ::std::os::raw::c_uint,
        uncacheable: ::std::os::raw::c_uint,
        was_304: ::std::os::raw::c_uint,
        is_bgfetch: ::std::os::raw::c_uint,
        is_hitmiss: ::std::os::raw::c_uint,
        is_hitpass: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let do_esi: u32 = unsafe { ::std::mem::transmute(do_esi) };
            do_esi as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let do_gzip: u32 = unsafe { ::std::mem::transmute(do_gzip) };
            do_gzip as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let do_gunzip: u32 = unsafe { ::std::mem::transmute(do_gunzip) };
            do_gunzip as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let do_stream: u32 = unsafe { ::std::mem::transmute(do_stream) };
            do_stream as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let uncacheable: u32 = unsafe { ::std::mem::transmute(uncacheable) };
            uncacheable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let was_304: u32 = unsafe { ::std::mem::transmute(was_304) };
            was_304 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let is_bgfetch: u32 = unsafe { ::std::mem::transmute(is_bgfetch) };
            is_bgfetch as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let is_hitmiss: u32 = unsafe { ::std::mem::transmute(is_hitmiss) };
            is_hitmiss as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let is_hitpass: u32 = unsafe { ::std::mem::transmute(is_hitpass) };
            is_hitpass as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct reqtop {
    pub magic: ::std::os::raw::c_uint,
    pub topreq: *mut req,
    pub vcl0: *mut vcl,
    pub privs: [vrt_privs; 1usize],
}
#[test]
fn bindgen_test_layout_reqtop() {
    assert_eq!(
        ::std::mem::size_of::<reqtop>(),
        32usize,
        concat!("Size of: ", stringify!(reqtop))
    );
    assert_eq!(
        ::std::mem::align_of::<reqtop>(),
        8usize,
        concat!("Alignment of ", stringify!(reqtop))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<reqtop>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(reqtop),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<reqtop>())).topreq as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(reqtop),
            "::",
            stringify!(topreq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<reqtop>())).vcl0 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(reqtop),
            "::",
            stringify!(vcl0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<reqtop>())).privs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(reqtop),
            "::",
            stringify!(privs)
        )
    );
}
impl Default for reqtop {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct req {
    pub magic: ::std::os::raw::c_uint,
    pub req_body_status: body_status_t,
    pub doclose: sess_close,
    pub restarts: ::std::os::raw::c_uint,
    pub esi_level: ::std::os::raw::c_uint,
    pub res_mode: ::std::os::raw::c_uint,
    pub req_step: *const req_step,
    pub top: *mut reqtop,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub err_code: u16,
    pub err_reason: *const ::std::os::raw::c_char,
    pub sp: *mut sess,
    pub wrk: *mut worker,
    pub task: [pool_task; 1usize],
    pub transport: *const transport,
    pub transport_priv: *mut ::std::os::raw::c_void,
    pub w_list: req__bindgen_ty_1,
    pub body_oc: *mut objcore,
    pub hash_objhead: *mut objhead,
    pub vary_b: *mut u8,
    pub vary_l: *mut u8,
    pub vary_e: *mut u8,
    pub digest: [u8; 32usize],
    pub d_ttl: vtim_dur,
    pub d_grace: vtim_dur,
    pub storage: *const stevedore,
    pub director_hint: *const director,
    pub vcl: *mut vcl,
    pub ws_req: usize,
    pub t_first: vtim_real,
    pub t_prev: vtim_real,
    pub t_req: vtim_real,
    pub htc: *mut http_conn,
    pub vfc: *mut vfp_ctx,
    pub client_identity: *const ::std::os::raw::c_char,
    pub http: *mut http,
    pub http0: *mut http,
    pub resp: *mut http,
    pub resp_len: intmax_t,
    pub ws: [ws; 1usize],
    pub objcore: *mut objcore,
    pub stale_oc: *mut objcore,
    pub vdc: *mut vdp_ctx,
    pub filter_list: *const ::std::os::raw::c_char,
    pub vsl: [vsl_log; 1usize],
    pub acct: acct_req,
    pub privs: [vrt_privs; 1usize],
    pub vcf: *mut vcf,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct req__bindgen_ty_1 {
    pub vtqe_next: *mut req,
    pub vtqe_prev: *mut *mut req,
}
#[test]
fn bindgen_test_layout_req__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<req__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(req__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<req__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(req__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req__bindgen_ty_1>())).vtqe_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(req__bindgen_ty_1),
            "::",
            stringify!(vtqe_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req__bindgen_ty_1>())).vtqe_prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(req__bindgen_ty_1),
            "::",
            stringify!(vtqe_prev)
        )
    );
}
impl Default for req__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_req() {
    assert_eq!(
        ::std::mem::size_of::<req>(),
        496usize,
        concat!("Size of: ", stringify!(req))
    );
    assert_eq!(
        ::std::mem::align_of::<req>(),
        8usize,
        concat!("Alignment of ", stringify!(req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).req_body_status as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(req_body_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).doclose as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(doclose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).restarts as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(restarts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).esi_level as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(esi_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).res_mode as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(res_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).req_step as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(req_step)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).top as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(top))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).err_code as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(err_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).err_reason as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(err_reason)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).sp as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(sp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).wrk as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(wrk))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).task as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(task))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).transport as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(transport)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).transport_priv as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(transport_priv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).w_list as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(w_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).body_oc as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(body_oc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).hash_objhead as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(hash_objhead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).vary_b as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(vary_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).vary_l as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(vary_l)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).vary_e as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(vary_e)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).digest as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(digest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).d_ttl as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(d_ttl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).d_grace as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(d_grace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).storage as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).director_hint as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(director_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).vcl as *const _ as usize },
        248usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(vcl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).ws_req as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(ws_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).t_first as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(t_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).t_prev as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(t_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).t_req as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(t_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).htc as *const _ as usize },
        288usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(htc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).vfc as *const _ as usize },
        296usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(vfc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).client_identity as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(client_identity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).http as *const _ as usize },
        312usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(http))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).http0 as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(http0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).resp as *const _ as usize },
        328usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(resp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).resp_len as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(resp_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).ws as *const _ as usize },
        344usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(ws))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).objcore as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(objcore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).stale_oc as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(stale_oc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).vdc as *const _ as usize },
        400usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(vdc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).filter_list as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(filter_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).vsl as *const _ as usize },
        416usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(vsl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).acct as *const _ as usize },
        448usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(acct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).privs as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(req),
            "::",
            stringify!(privs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<req>())).vcf as *const _ as usize },
        488usize,
        concat!("Offset of field: ", stringify!(req), "::", stringify!(vcf))
    );
}
impl Default for req {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl req {
    #[inline]
    pub fn disable_esi(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_esi(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hash_ignore_busy(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hash_ignore_busy(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hash_ignore_vary(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hash_ignore_vary(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hash_always_miss(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hash_always_miss(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_hit(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_hit(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_hitmiss(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_hitmiss(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_hitpass(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_hitpass(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn waitinglist(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_waitinglist(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn want100cont(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_want100cont(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn late100cont(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_late100cont(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disable_esi: ::std::os::raw::c_uint,
        hash_ignore_busy: ::std::os::raw::c_uint,
        hash_ignore_vary: ::std::os::raw::c_uint,
        hash_always_miss: ::std::os::raw::c_uint,
        is_hit: ::std::os::raw::c_uint,
        is_hitmiss: ::std::os::raw::c_uint,
        is_hitpass: ::std::os::raw::c_uint,
        waitinglist: ::std::os::raw::c_uint,
        want100cont: ::std::os::raw::c_uint,
        late100cont: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let disable_esi: u32 = unsafe { ::std::mem::transmute(disable_esi) };
            disable_esi as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hash_ignore_busy: u32 = unsafe { ::std::mem::transmute(hash_ignore_busy) };
            hash_ignore_busy as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hash_ignore_vary: u32 = unsafe { ::std::mem::transmute(hash_ignore_vary) };
            hash_ignore_vary as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let hash_always_miss: u32 = unsafe { ::std::mem::transmute(hash_always_miss) };
            hash_always_miss as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_hit: u32 = unsafe { ::std::mem::transmute(is_hit) };
            is_hit as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_hitmiss: u32 = unsafe { ::std::mem::transmute(is_hitmiss) };
            is_hitmiss as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let is_hitpass: u32 = unsafe { ::std::mem::transmute(is_hitpass) };
            is_hitpass as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let waitinglist: u32 = unsafe { ::std::mem::transmute(waitinglist) };
            waitinglist as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let want100cont: u32 = unsafe { ::std::mem::transmute(want100cont) };
            want100cont as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let late100cont: u32 = unsafe { ::std::mem::transmute(late100cont) };
            late100cont as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const sess_attr_SA_TRANSPORT: sess_attr = 0;
pub const sess_attr_SA_REMOTE_ADDR: sess_attr = 1;
pub const sess_attr_SA_LOCAL_ADDR: sess_attr = 2;
pub const sess_attr_SA_CLIENT_ADDR: sess_attr = 3;
pub const sess_attr_SA_SERVER_ADDR: sess_attr = 4;
pub const sess_attr_SA_CLIENT_IP: sess_attr = 5;
pub const sess_attr_SA_CLIENT_PORT: sess_attr = 6;
pub const sess_attr_SA_PROXY_TLV: sess_attr = 7;
pub const sess_attr_SA_PROTO_PRIV: sess_attr = 8;
pub const sess_attr_SA_LAST: sess_attr = 9;
pub type sess_attr = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sess {
    pub magic: ::std::os::raw::c_uint,
    pub sattr: [u16; 9usize],
    pub listen_sock: *mut listen_sock,
    pub refcnt: ::std::os::raw::c_int,
    pub fd: ::std::os::raw::c_int,
    pub vxid: u32,
    pub mtx: lock,
    pub pool: *mut pool,
    pub ws: [ws; 1usize],
    pub t_open: vtim_real,
    pub t_idle: vtim_real,
    pub timeout_idle: vtim_dur,
    pub timeout_linger: vtim_dur,
    pub send_timeout: vtim_dur,
    pub idle_send_timeout: vtim_dur,
}
#[test]
fn bindgen_test_layout_sess() {
    assert_eq!(
        ::std::mem::size_of::<sess>(),
        152usize,
        concat!("Size of: ", stringify!(sess))
    );
    assert_eq!(
        ::std::mem::align_of::<sess>(),
        8usize,
        concat!("Alignment of ", stringify!(sess))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sess>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sess>())).sattr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(sattr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sess>())).listen_sock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(listen_sock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sess>())).refcnt as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sess>())).fd as *const _ as usize },
        36usize,
        concat!("Offset of field: ", stringify!(sess), "::", stringify!(fd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sess>())).vxid as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(vxid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sess>())).mtx as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(sess), "::", stringify!(mtx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sess>())).pool as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sess>())).ws as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(sess), "::", stringify!(ws))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sess>())).t_open as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(t_open)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sess>())).t_idle as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(t_idle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sess>())).timeout_idle as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(timeout_idle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sess>())).timeout_linger as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(timeout_linger)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sess>())).send_timeout as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(send_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sess>())).idle_send_timeout as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sess),
            "::",
            stringify!(idle_send_timeout)
        )
    );
}
impl Default for sess {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn BAN_Build() -> *mut ban_proto;
}
extern "C" {
    pub fn BAN_AddTest(
        arg1: *mut ban_proto,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn BAN_Commit(b: *mut ban_proto) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn BAN_Abandon(b: *mut ban_proto);
}
extern "C" {
    pub static mut cli_thread: pthread_t;
}
extern "C" {
    pub fn HTTP_estimate(nhttp: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn HTTP_Clone(to: *mut http, fm: *const http);
}
extern "C" {
    pub fn HTTP_Dup(to: *mut http, fm: *const http);
}
extern "C" {
    pub fn HTTP_create(
        p: *mut ::std::os::raw::c_void,
        nhttp: u16,
        arg1: ::std::os::raw::c_uint,
    ) -> *mut http;
}
extern "C" {
    pub fn http_Status2Reason(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn http_EstimateWS(fm: *const http, how: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn http_PutResponse(
        to: *mut http,
        proto: *const ::std::os::raw::c_char,
        status: u16,
        response: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn http_FilterReq(to: *mut http, fm: *const http, how: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn HTTP_Encode(
        fm: *const http,
        arg1: *mut u8,
        len: ::std::os::raw::c_uint,
        how: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn HTTP_Decode(to: *mut http, fm: *const u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn http_ForceHeader(to: *mut http, arg1: hdr_t, val: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn http_PrintfHeader(to: *mut http, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn http_TimeHeader(to: *mut http, fmt: *const ::std::os::raw::c_char, now: vtim_real);
}
extern "C" {
    pub fn http_Proto(to: *mut http);
}
extern "C" {
    pub fn http_SetHeader(to: *mut http, header: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn http_SetH(
        to: *mut http,
        n: ::std::os::raw::c_uint,
        header: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn http_ForceField(
        to: *mut http,
        n: ::std::os::raw::c_uint,
        t: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn HTTP_Setup(arg1: *mut http, arg2: *mut ws, arg3: *mut vsl_log, arg4: VSL_tag_e);
}
extern "C" {
    pub fn http_Teardown(ht: *mut http);
}
extern "C" {
    pub fn http_GetHdr(
        hp: *const http,
        arg1: hdr_t,
        ptr: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn http_GetHdrToken(
        hp: *const http,
        arg1: hdr_t,
        token: *const ::std::os::raw::c_char,
        pb: *mut *const ::std::os::raw::c_char,
        pe: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn http_GetHdrField(
        hp: *const http,
        arg1: hdr_t,
        field: *const ::std::os::raw::c_char,
        ptr: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn http_GetHdrQ(hp: *const http, arg1: hdr_t, field: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn http_GetContentLength(hp: *const http) -> ssize_t;
}
extern "C" {
    pub fn http_GetContentRange(hp: *const http, lo: *mut ssize_t, hi: *mut ssize_t) -> ssize_t;
}
extern "C" {
    pub fn http_GetRange(
        hp: *const http,
        lo: *mut ssize_t,
        hi: *mut ssize_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn http_GetStatus(hp: *const http) -> u16;
}
extern "C" {
    pub fn http_IsStatus(hp: *const http, arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn http_SetStatus(to: *mut http, status: u16, reason: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn http_GetMethod(hp: *const http) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn http_HdrIs(
        hp: *const http,
        arg1: hdr_t,
        val: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn http_CopyHome(hp: *const http);
}
extern "C" {
    pub fn http_Unset(hp: *mut http, arg1: hdr_t);
}
extern "C" {
    pub fn http_CountHdr(hp: *const http, arg1: hdr_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn http_CollectHdr(hp: *mut http, arg1: hdr_t);
}
extern "C" {
    pub fn http_CollectHdrSep(hp: *mut http, arg1: hdr_t, sep: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn http_VSL_log(hp: *const http);
}
extern "C" {
    pub fn HTTP_Merge(arg1: *mut worker, arg2: *mut objcore, to: *mut http);
}
extern "C" {
    pub fn HTTP_GetStatusPack(arg1: *mut worker, oc: *mut objcore) -> u16;
}
extern "C" {
    pub fn HTTP_IterHdrPack(
        arg1: *mut worker,
        arg2: *mut objcore,
        arg3: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HTTP_GetHdrPack(
        arg1: *mut worker,
        arg2: *mut objcore,
        arg3: hdr_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn http_DoConnection(hp: *mut http, sc_close: sess_close) -> sess_close;
}
extern "C" {
    pub fn http_IsFiltered(
        hp: *const http,
        u: ::std::os::raw::c_uint,
        how: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut H_Accept: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Accept_Charset: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Accept_Encoding: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Accept_Language: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Accept_Ranges: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Age: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Allow: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Authorization: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Cache_Control: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Connection: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Content_Encoding: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Content_Language: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Content_Length: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Content_Location: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Content_MD5: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Content_Range: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Content_Type: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Cookie: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Date: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_ETag: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Expect: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Expires: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_From: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Host: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_HTTP2_Settings: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_If_Match: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_If_Modified_Since: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_If_None_Match: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_If_Range: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_If_Unmodified_Since: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Keep_Alive: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Last_Modified: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Location: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Max_Forwards: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Pragma: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Proxy_Authenticate: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Proxy_Authorization: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Range: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Referer: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Retry_After: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Server: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Set_Cookie: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_TE: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Trailer: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Transfer_Encoding: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Upgrade: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_User_Agent: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Vary: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Via: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_Warning: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_WWW_Authenticate: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H_X_Forwarded_For: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H__Status: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H__Proto: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut H__Reason: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn VXID_Get(arg1: *const worker, marker: u32) -> u32;
}
extern "C" {
    pub static mut witness_key: pthread_key_t;
}
extern "C" {
    pub fn Lck__Lock(lck: *mut lock, p: *const ::std::os::raw::c_char, l: ::std::os::raw::c_int);
}
extern "C" {
    pub fn Lck__Unlock(lck: *mut lock, p: *const ::std::os::raw::c_char, l: ::std::os::raw::c_int);
}
extern "C" {
    pub fn Lck__Trylock(
        lck: *mut lock,
        p: *const ::std::os::raw::c_char,
        l: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Lck__New(lck: *mut lock, arg1: *mut VSC_lck, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn Lck__Held(lck: *const lock) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Lck__Owned(lck: *const lock) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Lck_Delete(lck: *mut lock);
}
extern "C" {
    pub fn Lck_CondWait(
        cond: *mut pthread_cond_t,
        lck: *mut lock,
        arg1: vtim_real,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Lck_CreateClass(
        arg1: *mut *mut vsc_seg,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut VSC_lck;
}
extern "C" {
    pub fn Lck_DestroyClass(arg1: *mut *mut vsc_seg);
}
extern "C" {
    pub static mut lck_ban: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_busyobj: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_cli: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_director: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_exp: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_hcb: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_lru: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_mempool: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_objhdr: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_perpool: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_pipestat: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_probe: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_sess: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_conn_pool: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_vbe: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_vcapace: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_vcl: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_vxid: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_waiter: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_wq: *mut VSC_lck;
}
extern "C" {
    pub static mut lck_wstat: *mut VSC_lck;
}
extern "C" {
    pub fn ObjHasAttr(
        arg1: *mut worker,
        arg2: *mut objcore,
        arg3: obj_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ObjGetAttr(
        arg1: *mut worker,
        arg2: *mut objcore,
        arg3: obj_attr,
        len: *mut ssize_t,
    ) -> *const ::std::os::raw::c_void;
}
pub type objiterate_f = ::std::option::Option<
    unsafe extern "C" fn(
        priv_: *mut ::std::os::raw::c_void,
        flush: ::std::os::raw::c_uint,
        ptr: *const ::std::os::raw::c_void,
        len: ssize_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn ObjIterate(
        arg1: *mut worker,
        arg2: *mut objcore,
        priv_: *mut ::std::os::raw::c_void,
        func: objiterate_f,
        final_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ObjGetXID(arg1: *mut worker, arg2: *mut objcore) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ObjGetLen(arg1: *mut worker, arg2: *mut objcore) -> u64;
}
extern "C" {
    pub fn ObjGetDouble(
        arg1: *mut worker,
        arg2: *mut objcore,
        arg3: obj_attr,
        arg4: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ObjGetU32(
        arg1: *mut worker,
        arg2: *mut objcore,
        arg3: obj_attr,
        arg4: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ObjGetU64(
        arg1: *mut worker,
        arg2: *mut objcore,
        arg3: obj_attr,
        arg4: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ObjCheckFlag(
        arg1: *mut worker,
        arg2: *mut objcore,
        of: obj_flags,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VRB_Iterate(
        arg1: *mut worker,
        arg2: *mut vsl_log,
        arg3: *mut req,
        func: objiterate_f,
        priv_: *mut ::std::os::raw::c_void,
    ) -> ssize_t;
}
extern "C" {
    pub fn SES_Get_transport(
        sp: *const sess,
        dst: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_remote_addr(sp: *const sess, dst: *mut *mut suckaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_local_addr(sp: *const sess, dst: *mut *mut suckaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_client_addr(sp: *const sess, dst: *mut *mut suckaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_server_addr(sp: *const sess, dst: *mut *mut suckaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_client_ip(
        sp: *const sess,
        dst: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_client_port(
        sp: *const sess,
        dst: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_proxy_tlv(sp: *const sess, dst: *mut *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_proto_priv(sp: *const sess, dst: *mut *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SES_Get_String_Attr(sp: *const sess, a: sess_attr) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn VSLv(
        tag: VSL_tag_e,
        vxid: u32,
        fmt: *const ::std::os::raw::c_char,
        va: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn VSL(tag: VSL_tag_e, vxid: u32, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn VSLs(tag: VSL_tag_e, vxid: u32, s: *const strands);
}
extern "C" {
    pub fn VSLbv(
        arg1: *mut vsl_log,
        tag: VSL_tag_e,
        fmt: *const ::std::os::raw::c_char,
        va: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn VSLb(arg1: *mut vsl_log, tag: VSL_tag_e, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn VSLbt(arg1: *mut vsl_log, tag: VSL_tag_e, t: txt);
}
extern "C" {
    pub fn VSLbs(arg1: *mut vsl_log, tag: VSL_tag_e, s: *const strands);
}
extern "C" {
    pub fn VSLb_ts(
        arg1: *mut vsl_log,
        event: *const ::std::os::raw::c_char,
        first: vtim_real,
        pprev: *mut vtim_real,
        now: vtim_real,
    );
}
extern "C" {
    pub fn VSLb_bin(
        arg1: *mut vsl_log,
        arg2: VSL_tag_e,
        arg3: ssize_t,
        arg4: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn VCL_Name(arg1: *const vcl) -> *const ::std::os::raw::c_char;
}
pub type bgthread_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut worker,
        priv_: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    pub fn WRK_BgThread(
        thr: *mut pthread_t,
        name: *const ::std::os::raw::c_char,
        func: bgthread_t,
        priv_: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn WS_Init(
        ws: *mut ws,
        id: *const ::std::os::raw::c_char,
        space: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn WS_ReserveSize(arg1: *mut ws, arg2: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn WS_ReserveAll(arg1: *mut ws) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn WS_Release(ws: *mut ws, bytes: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn WS_ReleaseP(ws: *mut ws, ptr: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn WS_Assert(ws: *const ws);
}
extern "C" {
    pub fn WS_Reset(ws: *mut ws, arg1: usize);
}
extern "C" {
    pub fn WS_Alloc(ws: *mut ws, bytes: ::std::os::raw::c_uint) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn WS_Copy(
        ws: *mut ws,
        str_: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn WS_Snapshot(ws: *mut ws) -> usize;
}
extern "C" {
    pub fn WS_Allocated(
        ws: *const ws,
        ptr: *const ::std::os::raw::c_void,
        len: ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WS_Dump(
        ws: *const ws,
        arg1: ::std::os::raw::c_char,
        off: size_t,
        buf: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn WS_MarkOverflow(ws: *mut ws);
}
extern "C" {
    pub fn WS_Overflowed(ws: *const ws) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WS_Printf(
        ws: *mut ws,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn WS_VSB_new(arg1: *mut vsb, arg2: *mut ws);
}
extern "C" {
    pub fn WS_VSB_finish(
        arg1: *mut vsb,
        arg2: *mut ws,
        arg3: *mut size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn RFC2616_Ttl(
        arg1: *mut busyobj,
        now: vtim_real,
        t_origin: *mut vtim_real,
        ttl: *mut f32,
        grace: *mut f32,
        keep: *mut f32,
    );
}
extern "C" {
    pub fn RFC2616_Req_Gzip(arg1: *const http) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn RFC2616_Do_Cond(sp: *const req) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RFC2616_Weaken_Etag(hp: *mut http);
}
extern "C" {
    pub fn RFC2616_Vary_AE(hp: *mut http);
}
pub const vfp_status_VFP_ERROR: vfp_status = -1;
pub const vfp_status_VFP_OK: vfp_status = 0;
pub const vfp_status_VFP_END: vfp_status = 1;
pub const vfp_status_VFP_NULL: vfp_status = 2;
pub type vfp_status = ::std::os::raw::c_int;
pub type vfp_init_f = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut vfp_ctx, arg2: *mut vfp_entry) -> vfp_status,
>;
pub type vfp_pull_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut vfp_ctx,
        arg2: *mut vfp_entry,
        ptr: *mut ::std::os::raw::c_void,
        len: *mut ssize_t,
    ) -> vfp_status,
>;
pub type vfp_fini_f =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut vfp_ctx, arg2: *mut vfp_entry)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfp {
    pub name: *const ::std::os::raw::c_char,
    pub init: vfp_init_f,
    pub pull: vfp_pull_f,
    pub fini: vfp_fini_f,
    pub priv1: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_vfp() {
    assert_eq!(
        ::std::mem::size_of::<vfp>(),
        40usize,
        concat!("Size of: ", stringify!(vfp))
    );
    assert_eq!(
        ::std::mem::align_of::<vfp>(),
        8usize,
        concat!("Alignment of ", stringify!(vfp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfp>())).name as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(vfp), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfp>())).init as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(vfp), "::", stringify!(init))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfp>())).pull as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(vfp), "::", stringify!(pull))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfp>())).fini as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(vfp), "::", stringify!(fini))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfp>())).priv1 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp),
            "::",
            stringify!(priv1)
        )
    );
}
impl Default for vfp {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfp_entry {
    pub magic: ::std::os::raw::c_uint,
    pub closed: vfp_status,
    pub vfp: *const vfp,
    pub priv1: *mut ::std::os::raw::c_void,
    pub priv2: isize,
    pub list: vfp_entry__bindgen_ty_1,
    pub calls: u64,
    pub bytes_out: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfp_entry__bindgen_ty_1 {
    pub vtqe_next: *mut vfp_entry,
    pub vtqe_prev: *mut *mut vfp_entry,
}
#[test]
fn bindgen_test_layout_vfp_entry__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vfp_entry__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(vfp_entry__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vfp_entry__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(vfp_entry__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfp_entry__bindgen_ty_1>())).vtqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry__bindgen_ty_1),
            "::",
            stringify!(vtqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfp_entry__bindgen_ty_1>())).vtqe_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry__bindgen_ty_1),
            "::",
            stringify!(vtqe_prev)
        )
    );
}
impl Default for vfp_entry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_vfp_entry() {
    assert_eq!(
        ::std::mem::size_of::<vfp_entry>(),
        64usize,
        concat!("Size of: ", stringify!(vfp_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<vfp_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(vfp_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfp_entry>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfp_entry>())).closed as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry),
            "::",
            stringify!(closed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfp_entry>())).vfp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry),
            "::",
            stringify!(vfp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfp_entry>())).priv1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry),
            "::",
            stringify!(priv1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfp_entry>())).priv2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry),
            "::",
            stringify!(priv2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfp_entry>())).list as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfp_entry>())).calls as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry),
            "::",
            stringify!(calls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfp_entry>())).bytes_out as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry),
            "::",
            stringify!(bytes_out)
        )
    );
}
impl Default for vfp_entry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfp_entry_s {
    pub vtqh_first: *mut vfp_entry,
    pub vtqh_last: *mut *mut vfp_entry,
}
#[test]
fn bindgen_test_layout_vfp_entry_s() {
    assert_eq!(
        ::std::mem::size_of::<vfp_entry_s>(),
        16usize,
        concat!("Size of: ", stringify!(vfp_entry_s))
    );
    assert_eq!(
        ::std::mem::align_of::<vfp_entry_s>(),
        8usize,
        concat!("Alignment of ", stringify!(vfp_entry_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfp_entry_s>())).vtqh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry_s),
            "::",
            stringify!(vtqh_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfp_entry_s>())).vtqh_last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_entry_s),
            "::",
            stringify!(vtqh_last)
        )
    );
}
impl Default for vfp_entry_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfp_ctx {
    pub magic: ::std::os::raw::c_uint,
    pub failed: ::std::os::raw::c_int,
    pub req: *mut http,
    pub resp: *mut http,
    pub wrk: *mut worker,
    pub oc: *mut objcore,
    pub vfp: vfp_entry_s,
    pub vfp_nxt: *mut vfp_entry,
    pub obj_flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_vfp_ctx() {
    assert_eq!(
        ::std::mem::size_of::<vfp_ctx>(),
        72usize,
        concat!("Size of: ", stringify!(vfp_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<vfp_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(vfp_ctx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfp_ctx>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfp_ctx>())).failed as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(failed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfp_ctx>())).req as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfp_ctx>())).resp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(resp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfp_ctx>())).wrk as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(wrk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfp_ctx>())).oc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(oc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfp_ctx>())).vfp as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(vfp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfp_ctx>())).vfp_nxt as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(vfp_nxt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfp_ctx>())).obj_flags as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vfp_ctx),
            "::",
            stringify!(obj_flags)
        )
    );
}
impl Default for vfp_ctx {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VFP_Suck(
        arg1: *mut vfp_ctx,
        p: *mut ::std::os::raw::c_void,
        lp: *mut ssize_t,
    ) -> vfp_status;
}
extern "C" {
    pub fn VFP_Error(arg1: *mut vfp_ctx, fmt: *const ::std::os::raw::c_char, ...) -> vfp_status;
}
extern "C" {
    pub fn VRT_AddVFP(ctx: *const vrt_ctx, arg1: *const vfp);
}
extern "C" {
    pub fn VRT_RemoveVFP(ctx: *const vrt_ctx, arg1: *const vfp);
}
pub const vdp_action_VDP_NULL: vdp_action = 0;
pub const vdp_action_VDP_FLUSH: vdp_action = 1;
pub const vdp_action_VDP_END: vdp_action = 2;
pub type vdp_action = ::std::os::raw::c_uint;
pub type vdp_init_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut vdp_ctx,
        priv_: *mut *mut ::std::os::raw::c_void,
        arg2: *mut objcore,
    ) -> ::std::os::raw::c_int,
>;
pub type vdp_fini_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut vdp_ctx,
        priv_: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type vdp_bytes_f = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut vdp_ctx,
        arg2: vdp_action,
        priv_: *mut *mut ::std::os::raw::c_void,
        ptr: *const ::std::os::raw::c_void,
        len: ssize_t,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdp {
    pub name: *const ::std::os::raw::c_char,
    pub init: vdp_init_f,
    pub bytes: vdp_bytes_f,
    pub fini: vdp_fini_f,
}
#[test]
fn bindgen_test_layout_vdp() {
    assert_eq!(
        ::std::mem::size_of::<vdp>(),
        32usize,
        concat!("Size of: ", stringify!(vdp))
    );
    assert_eq!(
        ::std::mem::align_of::<vdp>(),
        8usize,
        concat!("Alignment of ", stringify!(vdp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdp>())).name as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(vdp), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdp>())).init as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(vdp), "::", stringify!(init))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdp>())).bytes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdp>())).fini as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(vdp), "::", stringify!(fini))
    );
}
impl Default for vdp {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdp_entry {
    pub magic: ::std::os::raw::c_uint,
    pub end: vdp_action,
    pub vdp: *const vdp,
    pub priv_: *mut ::std::os::raw::c_void,
    pub list: vdp_entry__bindgen_ty_1,
    pub calls: u64,
    pub bytes_in: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdp_entry__bindgen_ty_1 {
    pub vtqe_next: *mut vdp_entry,
    pub vtqe_prev: *mut *mut vdp_entry,
}
#[test]
fn bindgen_test_layout_vdp_entry__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vdp_entry__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(vdp_entry__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vdp_entry__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(vdp_entry__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vdp_entry__bindgen_ty_1>())).vtqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry__bindgen_ty_1),
            "::",
            stringify!(vtqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vdp_entry__bindgen_ty_1>())).vtqe_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry__bindgen_ty_1),
            "::",
            stringify!(vtqe_prev)
        )
    );
}
impl Default for vdp_entry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_vdp_entry() {
    assert_eq!(
        ::std::mem::size_of::<vdp_entry>(),
        56usize,
        concat!("Size of: ", stringify!(vdp_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<vdp_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(vdp_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdp_entry>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdp_entry>())).end as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdp_entry>())).vdp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry),
            "::",
            stringify!(vdp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdp_entry>())).priv_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdp_entry>())).list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdp_entry>())).calls as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry),
            "::",
            stringify!(calls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdp_entry>())).bytes_in as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry),
            "::",
            stringify!(bytes_in)
        )
    );
}
impl Default for vdp_entry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdp_entry_s {
    pub vtqh_first: *mut vdp_entry,
    pub vtqh_last: *mut *mut vdp_entry,
}
#[test]
fn bindgen_test_layout_vdp_entry_s() {
    assert_eq!(
        ::std::mem::size_of::<vdp_entry_s>(),
        16usize,
        concat!("Size of: ", stringify!(vdp_entry_s))
    );
    assert_eq!(
        ::std::mem::align_of::<vdp_entry_s>(),
        8usize,
        concat!("Alignment of ", stringify!(vdp_entry_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdp_entry_s>())).vtqh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry_s),
            "::",
            stringify!(vtqh_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdp_entry_s>())).vtqh_last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_entry_s),
            "::",
            stringify!(vtqh_last)
        )
    );
}
impl Default for vdp_entry_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdp_ctx {
    pub magic: ::std::os::raw::c_uint,
    pub retval: ::std::os::raw::c_int,
    pub bytes_done: u64,
    pub vdp: vdp_entry_s,
    pub nxt: *mut vdp_entry,
    pub wrk: *mut worker,
    pub vsl: *mut vsl_log,
    pub req: *mut req,
}
#[test]
fn bindgen_test_layout_vdp_ctx() {
    assert_eq!(
        ::std::mem::size_of::<vdp_ctx>(),
        64usize,
        concat!("Size of: ", stringify!(vdp_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<vdp_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(vdp_ctx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdp_ctx>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_ctx),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdp_ctx>())).retval as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_ctx),
            "::",
            stringify!(retval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdp_ctx>())).bytes_done as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_ctx),
            "::",
            stringify!(bytes_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdp_ctx>())).vdp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_ctx),
            "::",
            stringify!(vdp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdp_ctx>())).nxt as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_ctx),
            "::",
            stringify!(nxt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdp_ctx>())).wrk as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_ctx),
            "::",
            stringify!(wrk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdp_ctx>())).vsl as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_ctx),
            "::",
            stringify!(vsl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vdp_ctx>())).req as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vdp_ctx),
            "::",
            stringify!(req)
        )
    );
}
impl Default for vdp_ctx {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VDP_bytes(
        arg1: *mut vdp_ctx,
        act: vdp_action,
        arg2: *const ::std::os::raw::c_void,
        arg3: ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VRT_AddVDP(ctx: *const vrt_ctx, arg1: *const vdp);
}
extern "C" {
    pub fn VRT_RemoveVDP(ctx: *const vrt_ctx, arg1: *const vdp);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vsb {
    pub magic: ::std::os::raw::c_uint,
    pub s_error: ::std::os::raw::c_int,
    pub s_buf: *mut ::std::os::raw::c_char,
    pub s_size: ssize_t,
    pub s_len: ssize_t,
    pub s_flags: ::std::os::raw::c_int,
    pub s_indent: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_vsb() {
    assert_eq!(
        ::std::mem::size_of::<vsb>(),
        40usize,
        concat!("Size of: ", stringify!(vsb))
    );
    assert_eq!(
        ::std::mem::align_of::<vsb>(),
        8usize,
        concat!("Alignment of ", stringify!(vsb))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vsb>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vsb),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vsb>())).s_error as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vsb),
            "::",
            stringify!(s_error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vsb>())).s_buf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vsb),
            "::",
            stringify!(s_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vsb>())).s_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vsb),
            "::",
            stringify!(s_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vsb>())).s_len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vsb),
            "::",
            stringify!(s_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vsb>())).s_flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vsb),
            "::",
            stringify!(s_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vsb>())).s_indent as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(vsb),
            "::",
            stringify!(s_indent)
        )
    );
}
impl Default for vsb {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VSB_init(arg1: *mut vsb, arg2: *mut ::std::os::raw::c_void, arg3: ssize_t) -> *mut vsb;
}
extern "C" {
    pub fn VSB_new_auto() -> *mut vsb;
}
extern "C" {
    pub fn VSB_clear(arg1: *mut vsb);
}
extern "C" {
    pub fn VSB_bcat(
        arg1: *mut vsb,
        arg2: *const ::std::os::raw::c_void,
        arg3: ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSB_cat(arg1: *mut vsb, arg2: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSB_printf(
        arg1: *mut vsb,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSB_vprintf(
        arg1: *mut vsb,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSB_putc(arg1: *mut vsb, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSB_error(arg1: *const vsb) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSB_finish(arg1: *mut vsb) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VSB_data(arg1: *const vsb) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn VSB_len(arg1: *const vsb) -> ssize_t;
}
extern "C" {
    pub fn VSB_fini(arg1: *mut vsb);
}
extern "C" {
    pub fn VSB_destroy(arg1: *mut *mut vsb);
}
extern "C" {
    pub fn VSB_quote_pfx(
        arg1: *mut vsb,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        how: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn VSB_quote(
        arg1: *mut vsb,
        arg2: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        how: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn VSB_indent(arg1: *mut vsb, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn VSB_tofile(arg1: *const vsb, fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct http_conn {
    pub magic: ::std::os::raw::c_uint,
    pub rfd: *mut ::std::os::raw::c_int,
    pub doclose: sess_close,
    pub body_status: body_status_t,
    pub ws: *mut ws,
    pub rxbuf_b: *mut ::std::os::raw::c_char,
    pub rxbuf_e: *mut ::std::os::raw::c_char,
    pub pipeline_b: *mut ::std::os::raw::c_char,
    pub pipeline_e: *mut ::std::os::raw::c_char,
    pub content_length: ssize_t,
    pub priv_: *mut ::std::os::raw::c_void,
    pub first_byte_timeout: vtim_dur,
    pub between_bytes_timeout: vtim_dur,
}
#[test]
fn bindgen_test_layout_http_conn() {
    assert_eq!(
        ::std::mem::size_of::<http_conn>(),
        104usize,
        concat!("Size of: ", stringify!(http_conn))
    );
    assert_eq!(
        ::std::mem::align_of::<http_conn>(),
        8usize,
        concat!("Alignment of ", stringify!(http_conn))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<http_conn>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<http_conn>())).rfd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(rfd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<http_conn>())).doclose as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(doclose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<http_conn>())).body_status as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(body_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<http_conn>())).ws as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(ws)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<http_conn>())).rxbuf_b as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(rxbuf_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<http_conn>())).rxbuf_e as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(rxbuf_e)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<http_conn>())).pipeline_b as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(pipeline_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<http_conn>())).pipeline_e as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(pipeline_e)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<http_conn>())).content_length as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(content_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<http_conn>())).priv_ as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<http_conn>())).first_byte_timeout as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(first_byte_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<http_conn>())).between_bytes_timeout as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(http_conn),
            "::",
            stringify!(between_bytes_timeout)
        )
    );
}
impl Default for http_conn {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn VFP_Push(arg1: *mut vfp_ctx, arg2: *const vfp) -> *mut vfp_entry;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
impl Default for __va_list_tag {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vrt_priv {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v1l {
    pub _address: u8,
}
